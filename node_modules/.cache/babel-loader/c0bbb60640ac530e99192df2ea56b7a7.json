{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\nexport var padding = 5;\nconst VertexNodes = {\n  TOP_LEFT: 1,\n  TOP: 2,\n  TOP_RIGHT: 3,\n  RIGHT: 4,\n  BOTTOM_RIGHT: 5,\n  BOTTOM: 6,\n  BOTTOM_LEFT: 7,\n  LEFT: 8\n};\nexport class Vertex {\n  constructor(UUID, title, content, sx, sy, ex, ey) {\n    this.UUID = UUID;\n    this.title = title;\n    this.content = content;\n    this.sx = sx;\n    this.sy = sy;\n    this.width = ex - sx;\n    this.height = ey - sy;\n    this.icon = \"\";\n  }\n\n  setTitle(title) {\n    this.title = title;\n  }\n\n  setContent(content) {\n    this.content = content;\n  } //TODO: Check if there's a better way to store icon\n\n\n  setIcon(name) {\n    this.icon = name;\n  }\n\n  drawNode(canvasContext, x, y) {\n    canvasContext.beginPath();\n    canvasContext.arc(x, y, 3, 0, Math.PI * 2, false);\n    canvasContext.fill();\n    canvasContext.closePath();\n  }\n\n  draw(canvasContext) {\n    //todo: fix automatically increasing width when text is too long\n    // Font size\n    var fontSize = 12;\n    padding = 5; // Set font settings\n\n    canvasContext.font = fontSize + \"px Arial\";\n    canvasContext.fontSize = fontSize; // Find the maximum width of text and size the class accordingly\n\n    var measuredNameText = canvasContext.measureText(this.title) * 2;\n    var maxWidth = Math.max(measuredNameText.width, this.width);\n    var textHeight = padding * 2 + fontSize * 2; // Iterate over all content text lines\n\n    for (var i = 0; i < this.content.length; i++) {\n      var measuredText = canvasContext.measureText(this.content[i]);\n      maxWidth = Math.max(maxWidth, measuredText.width);\n      textHeight += fontSize + padding;\n    }\n\n    if (maxWidth > this.width) {\n      this.width = maxWidth;\n    } // Configure drawing for shadows\n    // And generally make it look nice\n\n\n    canvasContext.shadowOffsetX = 2.0;\n    canvasContext.shadowOffsetY = 2.0; // Decide rect width and height\n\n    var rectWidth = this.width;\n    var rectHeight = Math.max(this.height, textHeight); // Setup gradient fill\n\n    var grd = canvasContext.createLinearGradient(this.sx, this.sy, this.sx + rectWidth, this.sy + rectHeight);\n    grd.addColorStop(0, \"#e3895f\");\n    grd.addColorStop(1, \"#e66229\"); // Draw rect\n\n    canvasContext.fillStyle = grd;\n    canvasContext.fillRect(this.sx, this.sy, rectWidth, rectHeight);\n    canvasContext.strokeRect(this.sx, this.sy, rectWidth, fontSize + padding + padding);\n    canvasContext.strokeRect(this.sx, this.sy, rectWidth, rectHeight); // Prepare to Draw nodes\n\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.globalAlpha = 0.6;\n    this.drawNode(canvasContext, this.sx, this.sy); // Top Left\n\n    this.drawNode(canvasContext, this.sx + rectWidth / 2, this.sy); // Top\n\n    this.drawNode(canvasContext, this.sx + rectWidth, this.sy); // Top Right\n\n    this.drawNode(canvasContext, this.sx + rectWidth, this.sy + rectHeight / 2); // Right\n\n    this.drawNode(canvasContext, this.sx + rectWidth, this.sy + rectHeight); // Bottom Right\n\n    this.drawNode(canvasContext, this.sx + rectWidth / 2, this.sy + rectHeight); // Bottom\n\n    this.drawNode(canvasContext, this.sx, this.sy + rectHeight); // Bottom Left\n\n    this.drawNode(canvasContext, this.sx, this.sy + rectHeight / 2); // Left\n    // Finish drawing nodes\n\n    canvasContext.globalAlpha = 1.0; // Reset color for text\n\n    canvasContext.fillStyle = \"#000000\"; // Draw Height for text that will be increased to draw downward\n\n    var dy = padding + fontSize; // Disable shadows for text\n\n    canvasContext.shadowOffsetX = 0.0;\n    canvasContext.shadowOffsetY = 0.0; // Draw name\n\n    canvasContext.fillText(this.title, this.sx + padding, this.sy + dy);\n    dy += padding * 2 + fontSize; // Draw text\n\n    for (var i = 0; i < this.content.length; i++) {\n      canvasContext.fillText(this.content[i], this.sx + padding, this.sy + dy);\n      dy += fontSize + padding;\n    }\n  }\n\n  getNodeByVertexNode(vertexNode) {\n    switch (vertexNode) {\n      case VertexNodes.TOP_LEFT:\n        return [this.sx, this.sy, VertexNodes.TOP_LEFT, this];\n\n      case VertexNodes.TOP:\n        return [this.sx + this.width / 2, this.sy, VertexNodes.TOP, this];\n\n      case VertexNodes.TOP_RIGHT:\n        return [this.sx + this.width, this.sy, VertexNodes.TOP_RIGHT, this];\n\n      case VertexNodes.RIGHT:\n        return [this.sx + this.width, this.sy + this.height / 2, VertexNodes.RIGHT, this];\n\n      case VertexNodes.BOTTOM_RIGHT:\n        return [this.sx + this.width, this.sy + this.height, VertexNodes.BOTTOM_RIGHT, this];\n\n      case VertexNodes.BOTTOM:\n        return [this.sx + this.width / 2, this.sy + this.height, VertexNodes.BOTTOM, this];\n\n      case VertexNodes.BOTTOM_LEFT:\n        return [this.sx, this.sy + this.height, VertexNodes.BOTTOM_LEFT, this];\n\n      case VertexNodes.LEFT:\n        return [this.sx, this.sy + this.height / 2, VertexNodes.LEFT, this];\n    }\n  } // Returns all nodes for this object\n\n\n  getNodes() {\n    var nodes = [];\n    nodes.push(this.getNodeByVertexNode(VertexNodes.TOP_LEFT));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.TOP));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.TOP_RIGHT));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.RIGHT));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM_RIGHT));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM_LEFT));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.LEFT));\n    return nodes;\n  } // Checks if it intersects with point\n\n\n  intersects(x, y) {\n    if (x < this.sx) return false;\n    if (y < this.sy) return false;\n    if (x > this.sx + this.width) return false;\n    if (y > this.sy + this.height) return false;\n    return true;\n  }\n\n}","map":{"version":3,"sources":["/ocean/pacific/University/2020/IFB398/overdrive/src/datastructures/Vertex.js"],"names":["padding","VertexNodes","TOP_LEFT","TOP","TOP_RIGHT","RIGHT","BOTTOM_RIGHT","BOTTOM","BOTTOM_LEFT","LEFT","Vertex","constructor","UUID","title","content","sx","sy","ex","ey","width","height","icon","setTitle","setContent","setIcon","name","drawNode","canvasContext","x","y","beginPath","arc","Math","PI","fill","closePath","draw","fontSize","font","measuredNameText","measureText","maxWidth","max","textHeight","i","length","measuredText","shadowOffsetX","shadowOffsetY","rectWidth","rectHeight","grd","createLinearGradient","addColorStop","fillStyle","fillRect","strokeRect","globalAlpha","dy","fillText","getNodeByVertexNode","vertexNode","getNodes","nodes","push","intersects"],"mappings":"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","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nexport var padding = 5;\n\nconst VertexNodes = {\n    TOP_LEFT: 1,\n    TOP: 2,\n    TOP_RIGHT: 3,\n    RIGHT: 4,\n    BOTTOM_RIGHT: 5,\n    BOTTOM: 6,\n    BOTTOM_LEFT: 7,\n    LEFT: 8,\n}\n\nexport class Vertex {\n\n    UUID;\n    sx;\n    sy;\n    width;\n    height;\n    name;\n    content;\n    title;\n    icon;\n\n    constructor(UUID, title, content, sx, sy, ex, ey){\n        this.UUID = UUID;\n        this.title = title;\n        this.content = content;\n        this.sx = sx;\n        this.sy = sy;\n        this.width = ex-sx;\n        this.height = ey-sy;\n        this.icon = \"\";\n    }\n\n    setTitle(title){\n        this.title = title;\n    }\n\n    setContent(content){\n        this.content = content;\n    }\n\n    //TODO: Check if there's a better way to store icon\n    setIcon(name){\n        this.icon = name;\n    }\n\n    drawNode(canvasContext, x, y) {\n        canvasContext.beginPath();\n        canvasContext.arc(x, y, 3, 0, Math.PI*2, false);\n        canvasContext.fill();\n        canvasContext.closePath();\n    }\n\n    draw(canvasContext) {\n        //todo: fix automatically increasing width when text is too long\n\n        // Font size\n        var fontSize = 12;\n        padding = 5\n        // Set font settings\n        canvasContext.font = fontSize+\"px Arial\";\n        canvasContext.fontSize = fontSize;\n\n        // Find the maximum width of text and size the class accordingly\n        var measuredNameText = canvasContext.measureText(this.title)*2;\n        var maxWidth = Math.max(measuredNameText.width, this.width);\n        var textHeight = padding*2+fontSize*2;\n\n        // Iterate over all content text lines\n        for (var i = 0; i < this.content.length; i++) {\n            var measuredText = canvasContext.measureText(this.content[i]);\n            maxWidth = Math.max(maxWidth, measuredText.width);\n            textHeight += fontSize+padding;\n        }\n\n        if(maxWidth > this.width) {\n            this.width = maxWidth\n        }\n\n\n        // Configure drawing for shadows\n        // And generally make it look nice\n        canvasContext.shadowOffsetX = 2.0; canvasContext.shadowOffsetY = 2.0;\n\n        // Decide rect width and height\n        var rectWidth = this.width;\n        var rectHeight = Math.max(this.height, textHeight);\n\n        // Setup gradient fill\n        var grd = canvasContext.createLinearGradient(this.sx, this.sy, this.sx+rectWidth, this.sy+rectHeight);\n        grd.addColorStop(0, \"#e3895f\");\n        grd.addColorStop(1, \"#e66229\");\n\n        // Draw rect\n        canvasContext.fillStyle = grd;\n        canvasContext.fillRect(this.sx, this.sy, rectWidth, rectHeight);\n        canvasContext.strokeRect(this.sx, this.sy, rectWidth, fontSize+padding+padding);\n        canvasContext.strokeRect(this.sx, this.sy, rectWidth, rectHeight);\n\n        // Prepare to Draw nodes\n        canvasContext.fillStyle = \"#000000\";\n        canvasContext.globalAlpha = 0.6;\n\n        this.drawNode(canvasContext, this.sx, this.sy); // Top Left\n        this.drawNode(canvasContext, this.sx+rectWidth/2, this.sy); // Top\n        this.drawNode(canvasContext, this.sx+rectWidth, this.sy); // Top Right\n        this.drawNode(canvasContext, this.sx+rectWidth, this.sy+rectHeight/2); // Right\n        this.drawNode(canvasContext, this.sx+rectWidth, this.sy+rectHeight); // Bottom Right\n        this.drawNode(canvasContext, this.sx+rectWidth/2, this.sy+rectHeight); // Bottom\n        this.drawNode(canvasContext, this.sx, this.sy+rectHeight); // Bottom Left\n        this.drawNode(canvasContext, this.sx, this.sy+rectHeight/2); // Left\n\n        // Finish drawing nodes\n        canvasContext.globalAlpha = 1.0;\n\n        // Reset color for text\n        canvasContext.fillStyle = \"#000000\";\n\n        // Draw Height for text that will be increased to draw downward\n        var dy = padding+fontSize;\n\n        // Disable shadows for text\n        canvasContext.shadowOffsetX = 0.0; canvasContext.shadowOffsetY = 0.0;\n\n        // Draw name\n        canvasContext.fillText(this.title, this.sx+padding, this.sy+dy);\n        dy += padding*2 + fontSize;\n\n        // Draw text\n        for (var i = 0; i < this.content.length; i++) {\n            canvasContext.fillText(this.content[i], this.sx+padding, this.sy+dy);\n            dy += fontSize + padding;\n        }\n    }\n\n    getNodeByVertexNode(vertexNode) {\n        switch (vertexNode) {\n            case VertexNodes.TOP_LEFT:\n                return [this.sx,              this.sy,               VertexNodes.TOP_LEFT,     this];\n            case VertexNodes.TOP:\n                return [this.sx+this.width/2, this.sy,               VertexNodes.TOP,          this];\n            case VertexNodes.TOP_RIGHT:\n                return [this.sx+this.width,   this.sy,               VertexNodes.TOP_RIGHT,    this];\n            case VertexNodes.RIGHT:\n                return [this.sx+this.width,   this.sy+this.height/2, VertexNodes.RIGHT,        this];\n            case VertexNodes.BOTTOM_RIGHT:\n                return [this.sx+this.width,   this.sy+this.height,   VertexNodes.BOTTOM_RIGHT, this];\n            case VertexNodes.BOTTOM:\n                return [this.sx+this.width/2, this.sy+this.height,   VertexNodes.BOTTOM,       this];\n            case VertexNodes.BOTTOM_LEFT:\n                return [this.sx,              this.sy+this.height,   VertexNodes.BOTTOM_LEFT,  this];\n            case VertexNodes.LEFT:\n                return [this.sx,              this.sy+this.height/2, VertexNodes.LEFT,         this];\n        }\n    }\n\n    // Returns all nodes for this object\n    getNodes() {\n        var nodes = [];\n        nodes.push(this.getNodeByVertexNode(VertexNodes.TOP_LEFT));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.TOP));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.TOP_RIGHT));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.RIGHT));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM_RIGHT));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM_LEFT));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.LEFT));\n        return nodes;\n    }\n\n    // Checks if it intersects with point\n    intersects(x, y) {\n        if (x < this.sx) return false;\n        if (y < this.sy) return false;\n        if (x > this.sx+this.width) return false;\n        if (y > this.sy+this.height) return false;\n        return true;\n    }\n}"]},"metadata":{},"sourceType":"module"}