{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\nexport var padding = 5;\nconst VertexNodes = {\n  TOP_LEFT: 1,\n  TOP: 2,\n  TOP_RIGHT: 3,\n  RIGHT: 4,\n  BOTTOM_RIGHT: 5,\n  BOTTOM: 6,\n  BOTTOM_LEFT: 7,\n  LEFT: 8\n};\nexport class Vertex {\n  constructor(UUID, title, content, sx, sy, ex, ey) {\n    this.UUID = UUID;\n    this.title = title;\n    this.content = content;\n    this.sx = sx;\n    this.sy = sy;\n    this.width = ex - sx;\n    this.height = ey - sy;\n    this.icon = \"\";\n    this.children = [];\n  }\n\n  addChild(child) {\n    this.children.push(child);\n  }\n\n  setTitle(title) {\n    this.title = title;\n  }\n\n  setContent(content) {\n    this.content = content;\n  } //TODO: Check if there's a better way to store icon\n\n\n  setIcon(name) {\n    this.icon = name;\n  }\n\n  setSX(x) {\n    this.sx = x;\n  }\n\n  setSY(y) {\n    this.sy = y;\n  }\n\n  getBounds() {\n    return [this.sx, this.sy, this.sx + this.width, this.sy + this.height];\n  }\n\n  expandSide(side, x, y) {\n    switch (side) {\n      case \"topLeft\":\n        var ey = this.sy + this.height;\n        this.sy = y;\n        this.height = ey - this.sy;\n        var ex = this.sx + this.width;\n        this.sx = x;\n        this.width = ex - this.sx;\n        break;\n\n      case \"topRight\":\n        var ey = this.sy + this.height;\n        this.sy = y;\n        this.height = ey - this.sy;\n        this.width = x - this.sx;\n        break;\n\n      case \"bottomLeft\":\n        this.height = y - this.sy;\n        var ex = this.sx + this.width;\n        this.sx = x;\n        this.width = ex - this.sx;\n        break;\n\n      case \"bottomRight\":\n        this.height = y - this.sy;\n        this.width = x - this.sx;\n        break;\n\n      case \"left\":\n        var ex = this.sx + this.width;\n        this.sx = x;\n        this.width = ex - this.sx;\n        break;\n\n      case \"right\":\n        this.width = x - this.sx;\n        break;\n\n      case \"top\":\n        var ey = this.sy + this.height;\n        this.sy = y;\n        this.height = ey - this.sy;\n        break;\n\n      case \"bottom\":\n        this.height = y - this.sy;\n        break;\n    }\n  }\n\n  drawNode(canvasContext, x, y) {\n    canvasContext.beginPath();\n    canvasContext.arc(x, y, 3, 0, Math.PI * 2, false);\n    canvasContext.fill();\n    canvasContext.closePath();\n  }\n\n  draw(canvasContext) {\n    //todo: fix automatically increasing width when text is too long\n    // Font size\n    var fontSize = 12;\n    padding = 5; // Set font settings\n\n    canvasContext.font = fontSize + \"px Arial\";\n    canvasContext.fontSize = fontSize; // Find the maximum width of text and size the class accordingly\n\n    var measuredNameText = canvasContext.measureText(this.title) * 2;\n    var maxWidth = Math.max(measuredNameText.width, this.width);\n    var textHeight = padding * 2 + fontSize * 2; // Iterate over all content text lines\n\n    for (var i = 0; i < this.content.length; i++) {\n      var measuredText = canvasContext.measureText(this.content[i]);\n      maxWidth = Math.max(maxWidth, measuredText.width);\n      textHeight += fontSize + padding;\n    }\n\n    if (maxWidth > this.width) {\n      this.width = maxWidth;\n    } // Configure drawing for shadows\n    // And generally make it look nice\n\n\n    canvasContext.shadowOffsetX = 2.0;\n    canvasContext.shadowOffsetY = 2.0; // Decide rect width and height\n\n    var rectWidth = this.width;\n    var rectHeight = Math.max(this.height, textHeight); // Setup gradient fill\n\n    var grd = canvasContext.createLinearGradient(this.sx, this.sy, this.sx + rectWidth, this.sy + rectHeight);\n    grd.addColorStop(0, \"#e3895f\");\n    grd.addColorStop(1, \"#e66229\"); // Draw rect\n\n    canvasContext.fillStyle = grd;\n    canvasContext.fillRect(this.sx, this.sy, rectWidth, rectHeight);\n    canvasContext.strokeRect(this.sx, this.sy, rectWidth, fontSize + padding + padding);\n    canvasContext.strokeRect(this.sx, this.sy, rectWidth, rectHeight); // Prepare to Draw nodes\n\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.globalAlpha = 0.6;\n    this.drawNode(canvasContext, this.sx, this.sy); // Top Left\n\n    this.drawNode(canvasContext, this.sx + rectWidth / 2, this.sy); // Top\n\n    this.drawNode(canvasContext, this.sx + rectWidth, this.sy); // Top Right\n\n    this.drawNode(canvasContext, this.sx + rectWidth, this.sy + rectHeight / 2); // Right\n\n    this.drawNode(canvasContext, this.sx + rectWidth, this.sy + rectHeight); // Bottom Right\n\n    this.drawNode(canvasContext, this.sx + rectWidth / 2, this.sy + rectHeight); // Bottom\n\n    this.drawNode(canvasContext, this.sx, this.sy + rectHeight); // Bottom Left\n\n    this.drawNode(canvasContext, this.sx, this.sy + rectHeight / 2); // Left\n    // Finish drawing nodes\n\n    canvasContext.globalAlpha = 1.0; // Reset color for text\n\n    canvasContext.fillStyle = \"#000000\"; // Draw Height for text that will be increased to draw downward\n\n    var dy = padding + fontSize; // Disable shadows for text\n\n    canvasContext.shadowOffsetX = 0.0;\n    canvasContext.shadowOffsetY = 0.0; // Draw name\n\n    canvasContext.fillText(this.title, this.sx + padding, this.sy + dy);\n    dy += padding * 2 + fontSize; // Draw text\n\n    for (var i = 0; i < this.content.length; i++) {\n      canvasContext.fillText(this.content[i], this.sx + padding, this.sy + dy);\n      dy += fontSize + padding;\n    }\n  }\n\n  getNodeByVertexNode(vertexNode) {\n    switch (vertexNode) {\n      case VertexNodes.TOP_LEFT:\n        return [this.sx, this.sy, VertexNodes.TOP_LEFT, this];\n\n      case VertexNodes.TOP:\n        return [this.sx + this.width / 2, this.sy, VertexNodes.TOP, this];\n\n      case VertexNodes.TOP_RIGHT:\n        return [this.sx + this.width, this.sy, VertexNodes.TOP_RIGHT, this];\n\n      case VertexNodes.RIGHT:\n        return [this.sx + this.width, this.sy + this.height / 2, VertexNodes.RIGHT, this];\n\n      case VertexNodes.BOTTOM_RIGHT:\n        return [this.sx + this.width, this.sy + this.height, VertexNodes.BOTTOM_RIGHT, this];\n\n      case VertexNodes.BOTTOM:\n        return [this.sx + this.width / 2, this.sy + this.height, VertexNodes.BOTTOM, this];\n\n      case VertexNodes.BOTTOM_LEFT:\n        return [this.sx, this.sy + this.height, VertexNodes.BOTTOM_LEFT, this];\n\n      case VertexNodes.LEFT:\n        return [this.sx, this.sy + this.height / 2, VertexNodes.LEFT, this];\n    }\n  } // Returns all nodes for this object\n\n\n  getNodes() {\n    var nodes = [];\n    nodes.push(this.getNodeByVertexNode(VertexNodes.TOP_LEFT));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.TOP));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.TOP_RIGHT));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.RIGHT));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM_RIGHT));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM_LEFT));\n    nodes.push(this.getNodeByVertexNode(VertexNodes.LEFT));\n    return nodes;\n  } // Checks if it intersects with point\n\n\n  intersects(x, y) {\n    if (x < this.sx) return false;\n    if (y < this.sy) return false;\n    if (x > this.sx + this.width) return false;\n    if (y > this.sy + this.height) return false;\n    return true;\n  }\n\n}","map":{"version":3,"sources":["/ocean/pacific/University/2020/IFB398/overdrive/src/DataStructures/Vertex.js"],"names":["padding","VertexNodes","TOP_LEFT","TOP","TOP_RIGHT","RIGHT","BOTTOM_RIGHT","BOTTOM","BOTTOM_LEFT","LEFT","Vertex","constructor","UUID","title","content","sx","sy","ex","ey","width","height","icon","children","addChild","child","push","setTitle","setContent","setIcon","name","setSX","x","setSY","y","getBounds","expandSide","side","drawNode","canvasContext","beginPath","arc","Math","PI","fill","closePath","draw","fontSize","font","measuredNameText","measureText","maxWidth","max","textHeight","i","length","measuredText","shadowOffsetX","shadowOffsetY","rectWidth","rectHeight","grd","createLinearGradient","addColorStop","fillStyle","fillRect","strokeRect","globalAlpha","dy","fillText","getNodeByVertexNode","vertexNode","getNodes","nodes","intersects"],"mappings":"AAAA;;;AAIA,OAAO,IAAIA,OAAO,GAAG,CAAd;AAEP,MAAMC,WAAW,GAAG;AAChBC,EAAAA,QAAQ,EAAE,CADM;AAEhBC,EAAAA,GAAG,EAAE,CAFW;AAGhBC,EAAAA,SAAS,EAAE,CAHK;AAIhBC,EAAAA,KAAK,EAAE,CAJS;AAKhBC,EAAAA,YAAY,EAAE,CALE;AAMhBC,EAAAA,MAAM,EAAE,CANQ;AAOhBC,EAAAA,WAAW,EAAE,CAPG;AAQhBC,EAAAA,IAAI,EAAE;AARU,CAApB;AAWA,OAAO,MAAMC,MAAN,CAAa;AAahBC,EAAAA,WAAW,CAACC,IAAD,EAAOC,KAAP,EAAcC,OAAd,EAAuBC,EAAvB,EAA2BC,EAA3B,EAA+BC,EAA/B,EAAmCC,EAAnC,EAAsC;AAC7C,SAAKN,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,EAAL,GAAUA,EAAV;AACA,SAAKC,EAAL,GAAUA,EAAV;AACA,SAAKG,KAAL,GAAaF,EAAE,GAACF,EAAhB;AACA,SAAKK,MAAL,GAAcF,EAAE,GAACF,EAAjB;AACA,SAAKK,IAAL,GAAY,EAAZ;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACH;;AAEDC,EAAAA,QAAQ,CAACC,KAAD,EAAO;AACX,SAAKF,QAAL,CAAcG,IAAd,CAAmBD,KAAnB;AACH;;AAEDE,EAAAA,QAAQ,CAACb,KAAD,EAAO;AACX,SAAKA,KAAL,GAAaA,KAAb;AACH;;AAEDc,EAAAA,UAAU,CAACb,OAAD,EAAS;AACf,SAAKA,OAAL,GAAeA,OAAf;AACH,GAnCe,CAqChB;;;AACAc,EAAAA,OAAO,CAACC,IAAD,EAAM;AACT,SAAKR,IAAL,GAAYQ,IAAZ;AACH;;AAEDC,EAAAA,KAAK,CAACC,CAAD,EAAG;AACJ,SAAKhB,EAAL,GAAUgB,CAAV;AACH;;AAEDC,EAAAA,KAAK,CAACC,CAAD,EAAG;AACJ,SAAKjB,EAAL,GAAUiB,CAAV;AACH;;AAEDC,EAAAA,SAAS,GAAE;AACP,WAAO,CAAC,KAAKnB,EAAN,EAAS,KAAKC,EAAd,EAAiB,KAAKD,EAAL,GAAQ,KAAKI,KAA9B,EAAoC,KAAKH,EAAL,GAAQ,KAAKI,MAAjD,CAAP;AACH;;AAEDe,EAAAA,UAAU,CAACC,IAAD,EAAOL,CAAP,EAAUE,CAAV,EAAa;AACnB,YAAQG,IAAR;AAEI,WAAK,SAAL;AACI,YAAIlB,EAAE,GAAG,KAAKF,EAAL,GAAU,KAAKI,MAAxB;AACA,aAAKJ,EAAL,GAAUiB,CAAV;AACA,aAAKb,MAAL,GAAcF,EAAE,GAAC,KAAKF,EAAtB;AACA,YAAIC,EAAE,GAAG,KAAKF,EAAL,GAAU,KAAKI,KAAxB;AACA,aAAKJ,EAAL,GAAUgB,CAAV;AACA,aAAKZ,KAAL,GAAaF,EAAE,GAAC,KAAKF,EAArB;AACA;;AAEJ,WAAK,UAAL;AACI,YAAIG,EAAE,GAAG,KAAKF,EAAL,GAAU,KAAKI,MAAxB;AACA,aAAKJ,EAAL,GAAUiB,CAAV;AACA,aAAKb,MAAL,GAAcF,EAAE,GAAC,KAAKF,EAAtB;AACA,aAAKG,KAAL,GAAaY,CAAC,GAAC,KAAKhB,EAApB;AACA;;AAEJ,WAAK,YAAL;AACI,aAAKK,MAAL,GAAca,CAAC,GAAC,KAAKjB,EAArB;AACA,YAAIC,EAAE,GAAG,KAAKF,EAAL,GAAU,KAAKI,KAAxB;AACA,aAAKJ,EAAL,GAAUgB,CAAV;AACA,aAAKZ,KAAL,GAAaF,EAAE,GAAC,KAAKF,EAArB;AACA;;AAEJ,WAAK,aAAL;AACI,aAAKK,MAAL,GAAca,CAAC,GAAC,KAAKjB,EAArB;AACA,aAAKG,KAAL,GAAaY,CAAC,GAAC,KAAKhB,EAApB;AACA;;AAEJ,WAAK,MAAL;AACI,YAAIE,EAAE,GAAG,KAAKF,EAAL,GAAU,KAAKI,KAAxB;AACA,aAAKJ,EAAL,GAAUgB,CAAV;AACA,aAAKZ,KAAL,GAAaF,EAAE,GAAC,KAAKF,EAArB;AAEA;;AACJ,WAAK,OAAL;AACI,aAAKI,KAAL,GAAaY,CAAC,GAAC,KAAKhB,EAApB;AACA;;AAEJ,WAAK,KAAL;AACI,YAAIG,EAAE,GAAG,KAAKF,EAAL,GAAU,KAAKI,MAAxB;AACA,aAAKJ,EAAL,GAAUiB,CAAV;AACA,aAAKb,MAAL,GAAcF,EAAE,GAAC,KAAKF,EAAtB;AACA;;AAEJ,WAAK,QAAL;AACI,aAAKI,MAAL,GAAca,CAAC,GAAC,KAAKjB,EAArB;AACA;AAhDR;AAkDH;;AAEDqB,EAAAA,QAAQ,CAACC,aAAD,EAAgBP,CAAhB,EAAmBE,CAAnB,EAAsB;AAC1BK,IAAAA,aAAa,CAACC,SAAd;AACAD,IAAAA,aAAa,CAACE,GAAd,CAAkBT,CAAlB,EAAqBE,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,EAA8BQ,IAAI,CAACC,EAAL,GAAQ,CAAtC,EAAyC,KAAzC;AACAJ,IAAAA,aAAa,CAACK,IAAd;AACAL,IAAAA,aAAa,CAACM,SAAd;AACH;;AAEDC,EAAAA,IAAI,CAACP,aAAD,EAAgB;AAChB;AAEA;AACA,QAAIQ,QAAQ,GAAG,EAAf;AACA9C,IAAAA,OAAO,GAAG,CAAV,CALgB,CAMhB;;AACAsC,IAAAA,aAAa,CAACS,IAAd,GAAqBD,QAAQ,GAAC,UAA9B;AACAR,IAAAA,aAAa,CAACQ,QAAd,GAAyBA,QAAzB,CARgB,CAUhB;;AACA,QAAIE,gBAAgB,GAAGV,aAAa,CAACW,WAAd,CAA0B,KAAKpC,KAA/B,IAAsC,CAA7D;AACA,QAAIqC,QAAQ,GAAGT,IAAI,CAACU,GAAL,CAASH,gBAAgB,CAAC7B,KAA1B,EAAiC,KAAKA,KAAtC,CAAf;AACA,QAAIiC,UAAU,GAAGpD,OAAO,GAAC,CAAR,GAAU8C,QAAQ,GAAC,CAApC,CAbgB,CAehB;;AACA,SAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvC,OAAL,CAAawC,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;AAC1C,UAAIE,YAAY,GAAGjB,aAAa,CAACW,WAAd,CAA0B,KAAKnC,OAAL,CAAauC,CAAb,CAA1B,CAAnB;AACAH,MAAAA,QAAQ,GAAGT,IAAI,CAACU,GAAL,CAASD,QAAT,EAAmBK,YAAY,CAACpC,KAAhC,CAAX;AACAiC,MAAAA,UAAU,IAAIN,QAAQ,GAAC9C,OAAvB;AACH;;AAED,QAAGkD,QAAQ,GAAG,KAAK/B,KAAnB,EAA0B;AACtB,WAAKA,KAAL,GAAa+B,QAAb;AACH,KAxBe,CA2BhB;AACA;;;AACAZ,IAAAA,aAAa,CAACkB,aAAd,GAA8B,GAA9B;AAAmClB,IAAAA,aAAa,CAACmB,aAAd,GAA8B,GAA9B,CA7BnB,CA+BhB;;AACA,QAAIC,SAAS,GAAG,KAAKvC,KAArB;AACA,QAAIwC,UAAU,GAAGlB,IAAI,CAACU,GAAL,CAAS,KAAK/B,MAAd,EAAsBgC,UAAtB,CAAjB,CAjCgB,CAmChB;;AACA,QAAIQ,GAAG,GAAGtB,aAAa,CAACuB,oBAAd,CAAmC,KAAK9C,EAAxC,EAA4C,KAAKC,EAAjD,EAAqD,KAAKD,EAAL,GAAQ2C,SAA7D,EAAwE,KAAK1C,EAAL,GAAQ2C,UAAhF,CAAV;AACAC,IAAAA,GAAG,CAACE,YAAJ,CAAiB,CAAjB,EAAoB,SAApB;AACAF,IAAAA,GAAG,CAACE,YAAJ,CAAiB,CAAjB,EAAoB,SAApB,EAtCgB,CAwChB;;AACAxB,IAAAA,aAAa,CAACyB,SAAd,GAA0BH,GAA1B;AACAtB,IAAAA,aAAa,CAAC0B,QAAd,CAAuB,KAAKjD,EAA5B,EAAgC,KAAKC,EAArC,EAAyC0C,SAAzC,EAAoDC,UAApD;AACArB,IAAAA,aAAa,CAAC2B,UAAd,CAAyB,KAAKlD,EAA9B,EAAkC,KAAKC,EAAvC,EAA2C0C,SAA3C,EAAsDZ,QAAQ,GAAC9C,OAAT,GAAiBA,OAAvE;AACAsC,IAAAA,aAAa,CAAC2B,UAAd,CAAyB,KAAKlD,EAA9B,EAAkC,KAAKC,EAAvC,EAA2C0C,SAA3C,EAAsDC,UAAtD,EA5CgB,CA8ChB;;AACArB,IAAAA,aAAa,CAACyB,SAAd,GAA0B,SAA1B;AACAzB,IAAAA,aAAa,CAAC4B,WAAd,GAA4B,GAA5B;AAEA,SAAK7B,QAAL,CAAcC,aAAd,EAA6B,KAAKvB,EAAlC,EAAsC,KAAKC,EAA3C,EAlDgB,CAkDgC;;AAChD,SAAKqB,QAAL,CAAcC,aAAd,EAA6B,KAAKvB,EAAL,GAAQ2C,SAAS,GAAC,CAA/C,EAAkD,KAAK1C,EAAvD,EAnDgB,CAmD4C;;AAC5D,SAAKqB,QAAL,CAAcC,aAAd,EAA6B,KAAKvB,EAAL,GAAQ2C,SAArC,EAAgD,KAAK1C,EAArD,EApDgB,CAoD0C;;AAC1D,SAAKqB,QAAL,CAAcC,aAAd,EAA6B,KAAKvB,EAAL,GAAQ2C,SAArC,EAAgD,KAAK1C,EAAL,GAAQ2C,UAAU,GAAC,CAAnE,EArDgB,CAqDuD;;AACvE,SAAKtB,QAAL,CAAcC,aAAd,EAA6B,KAAKvB,EAAL,GAAQ2C,SAArC,EAAgD,KAAK1C,EAAL,GAAQ2C,UAAxD,EAtDgB,CAsDqD;;AACrE,SAAKtB,QAAL,CAAcC,aAAd,EAA6B,KAAKvB,EAAL,GAAQ2C,SAAS,GAAC,CAA/C,EAAkD,KAAK1C,EAAL,GAAQ2C,UAA1D,EAvDgB,CAuDuD;;AACvE,SAAKtB,QAAL,CAAcC,aAAd,EAA6B,KAAKvB,EAAlC,EAAsC,KAAKC,EAAL,GAAQ2C,UAA9C,EAxDgB,CAwD2C;;AAC3D,SAAKtB,QAAL,CAAcC,aAAd,EAA6B,KAAKvB,EAAlC,EAAsC,KAAKC,EAAL,GAAQ2C,UAAU,GAAC,CAAzD,EAzDgB,CAyD6C;AAE7D;;AACArB,IAAAA,aAAa,CAAC4B,WAAd,GAA4B,GAA5B,CA5DgB,CA8DhB;;AACA5B,IAAAA,aAAa,CAACyB,SAAd,GAA0B,SAA1B,CA/DgB,CAiEhB;;AACA,QAAII,EAAE,GAAGnE,OAAO,GAAC8C,QAAjB,CAlEgB,CAoEhB;;AACAR,IAAAA,aAAa,CAACkB,aAAd,GAA8B,GAA9B;AAAmClB,IAAAA,aAAa,CAACmB,aAAd,GAA8B,GAA9B,CArEnB,CAuEhB;;AACAnB,IAAAA,aAAa,CAAC8B,QAAd,CAAuB,KAAKvD,KAA5B,EAAmC,KAAKE,EAAL,GAAQf,OAA3C,EAAoD,KAAKgB,EAAL,GAAQmD,EAA5D;AACAA,IAAAA,EAAE,IAAInE,OAAO,GAAC,CAAR,GAAY8C,QAAlB,CAzEgB,CA2EhB;;AACA,SAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKvC,OAAL,CAAawC,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;AAC1Cf,MAAAA,aAAa,CAAC8B,QAAd,CAAuB,KAAKtD,OAAL,CAAauC,CAAb,CAAvB,EAAwC,KAAKtC,EAAL,GAAQf,OAAhD,EAAyD,KAAKgB,EAAL,GAAQmD,EAAjE;AACAA,MAAAA,EAAE,IAAIrB,QAAQ,GAAG9C,OAAjB;AACH;AACJ;;AAEDqE,EAAAA,mBAAmB,CAACC,UAAD,EAAa;AAC5B,YAAQA,UAAR;AACI,WAAKrE,WAAW,CAACC,QAAjB;AACI,eAAO,CAAC,KAAKa,EAAN,EAAuB,KAAKC,EAA5B,EAA8Cf,WAAW,CAACC,QAA1D,EAAwE,IAAxE,CAAP;;AACJ,WAAKD,WAAW,CAACE,GAAjB;AACI,eAAO,CAAC,KAAKY,EAAL,GAAQ,KAAKI,KAAL,GAAW,CAApB,EAAuB,KAAKH,EAA5B,EAA8Cf,WAAW,CAACE,GAA1D,EAAwE,IAAxE,CAAP;;AACJ,WAAKF,WAAW,CAACG,SAAjB;AACI,eAAO,CAAC,KAAKW,EAAL,GAAQ,KAAKI,KAAd,EAAuB,KAAKH,EAA5B,EAA8Cf,WAAW,CAACG,SAA1D,EAAwE,IAAxE,CAAP;;AACJ,WAAKH,WAAW,CAACI,KAAjB;AACI,eAAO,CAAC,KAAKU,EAAL,GAAQ,KAAKI,KAAd,EAAuB,KAAKH,EAAL,GAAQ,KAAKI,MAAL,GAAY,CAA3C,EAA8CnB,WAAW,CAACI,KAA1D,EAAwE,IAAxE,CAAP;;AACJ,WAAKJ,WAAW,CAACK,YAAjB;AACI,eAAO,CAAC,KAAKS,EAAL,GAAQ,KAAKI,KAAd,EAAuB,KAAKH,EAAL,GAAQ,KAAKI,MAApC,EAA8CnB,WAAW,CAACK,YAA1D,EAAwE,IAAxE,CAAP;;AACJ,WAAKL,WAAW,CAACM,MAAjB;AACI,eAAO,CAAC,KAAKQ,EAAL,GAAQ,KAAKI,KAAL,GAAW,CAApB,EAAuB,KAAKH,EAAL,GAAQ,KAAKI,MAApC,EAA8CnB,WAAW,CAACM,MAA1D,EAAwE,IAAxE,CAAP;;AACJ,WAAKN,WAAW,CAACO,WAAjB;AACI,eAAO,CAAC,KAAKO,EAAN,EAAuB,KAAKC,EAAL,GAAQ,KAAKI,MAApC,EAA8CnB,WAAW,CAACO,WAA1D,EAAwE,IAAxE,CAAP;;AACJ,WAAKP,WAAW,CAACQ,IAAjB;AACI,eAAO,CAAC,KAAKM,EAAN,EAAuB,KAAKC,EAAL,GAAQ,KAAKI,MAAL,GAAY,CAA3C,EAA8CnB,WAAW,CAACQ,IAA1D,EAAwE,IAAxE,CAAP;AAhBR;AAkBH,GAvNe,CAyNhB;;;AACA8D,EAAAA,QAAQ,GAAG;AACP,QAAIC,KAAK,GAAG,EAAZ;AACAA,IAAAA,KAAK,CAAC/C,IAAN,CAAW,KAAK4C,mBAAL,CAAyBpE,WAAW,CAACC,QAArC,CAAX;AACAsE,IAAAA,KAAK,CAAC/C,IAAN,CAAW,KAAK4C,mBAAL,CAAyBpE,WAAW,CAACE,GAArC,CAAX;AACAqE,IAAAA,KAAK,CAAC/C,IAAN,CAAW,KAAK4C,mBAAL,CAAyBpE,WAAW,CAACG,SAArC,CAAX;AACAoE,IAAAA,KAAK,CAAC/C,IAAN,CAAW,KAAK4C,mBAAL,CAAyBpE,WAAW,CAACI,KAArC,CAAX;AACAmE,IAAAA,KAAK,CAAC/C,IAAN,CAAW,KAAK4C,mBAAL,CAAyBpE,WAAW,CAACK,YAArC,CAAX;AACAkE,IAAAA,KAAK,CAAC/C,IAAN,CAAW,KAAK4C,mBAAL,CAAyBpE,WAAW,CAACM,MAArC,CAAX;AACAiE,IAAAA,KAAK,CAAC/C,IAAN,CAAW,KAAK4C,mBAAL,CAAyBpE,WAAW,CAACO,WAArC,CAAX;AACAgE,IAAAA,KAAK,CAAC/C,IAAN,CAAW,KAAK4C,mBAAL,CAAyBpE,WAAW,CAACQ,IAArC,CAAX;AACA,WAAO+D,KAAP;AACH,GArOe,CAuOhB;;;AACAC,EAAAA,UAAU,CAAC1C,CAAD,EAAIE,CAAJ,EAAO;AACb,QAAIF,CAAC,GAAG,KAAKhB,EAAb,EAAiB,OAAO,KAAP;AACjB,QAAIkB,CAAC,GAAG,KAAKjB,EAAb,EAAiB,OAAO,KAAP;AACjB,QAAIe,CAAC,GAAG,KAAKhB,EAAL,GAAQ,KAAKI,KAArB,EAA4B,OAAO,KAAP;AAC5B,QAAIc,CAAC,GAAG,KAAKjB,EAAL,GAAQ,KAAKI,MAArB,EAA6B,OAAO,KAAP;AAC7B,WAAO,IAAP;AACH;;AA9Oe","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nexport var padding = 5;\n\nconst VertexNodes = {\n    TOP_LEFT: 1,\n    TOP: 2,\n    TOP_RIGHT: 3,\n    RIGHT: 4,\n    BOTTOM_RIGHT: 5,\n    BOTTOM: 6,\n    BOTTOM_LEFT: 7,\n    LEFT: 8,\n}\n\nexport class Vertex {\n\n    UUID;\n    sx;\n    sy;\n    width;\n    height;\n    name;\n    content;\n    title;\n    icon;\n    children;\n\n    constructor(UUID, title, content, sx, sy, ex, ey){\n        this.UUID = UUID;\n        this.title = title;\n        this.content = content;\n        this.sx = sx;\n        this.sy = sy;\n        this.width = ex-sx;\n        this.height = ey-sy;\n        this.icon = \"\";\n        this.children = [];\n    }\n\n    addChild(child){\n        this.children.push(child)\n    }\n\n    setTitle(title){\n        this.title = title;\n    }\n\n    setContent(content){\n        this.content = content;\n    }\n\n    //TODO: Check if there's a better way to store icon\n    setIcon(name){\n        this.icon = name;\n    }\n\n    setSX(x){\n        this.sx = x\n    }\n\n    setSY(y){\n        this.sy = y\n    }\n\n    getBounds(){\n        return [this.sx,this.sy,this.sx+this.width,this.sy+this.height]\n    }\n\n    expandSide(side, x, y) {\n        switch (side) {\n\n            case \"topLeft\":\n                var ey = this.sy + this.height;\n                this.sy = y;\n                this.height = ey-this.sy;\n                var ex = this.sx + this.width;\n                this.sx = x;\n                this.width = ex-this.sx;\n                break;\n\n            case \"topRight\":\n                var ey = this.sy + this.height;\n                this.sy = y;\n                this.height = ey-this.sy;\n                this.width = x-this.sx;\n                break;\n\n            case \"bottomLeft\":\n                this.height = y-this.sy;\n                var ex = this.sx + this.width;\n                this.sx = x;\n                this.width = ex-this.sx;\n                break;\n\n            case \"bottomRight\":\n                this.height = y-this.sy;\n                this.width = x-this.sx;\n                break;\n\n            case \"left\":\n                var ex = this.sx + this.width;\n                this.sx = x;\n                this.width = ex-this.sx;\n\n                break;\n            case \"right\":\n                this.width = x-this.sx;\n                break;\n\n            case \"top\":\n                var ey = this.sy + this.height;\n                this.sy = y;\n                this.height = ey-this.sy;\n                break;\n\n            case \"bottom\":\n                this.height = y-this.sy;\n                break;\n        }\n    }\n\n    drawNode(canvasContext, x, y) {\n        canvasContext.beginPath();\n        canvasContext.arc(x, y, 3, 0, Math.PI*2, false);\n        canvasContext.fill();\n        canvasContext.closePath();\n    }\n\n    draw(canvasContext) {\n        //todo: fix automatically increasing width when text is too long\n\n        // Font size\n        var fontSize = 12;\n        padding = 5\n        // Set font settings\n        canvasContext.font = fontSize+\"px Arial\";\n        canvasContext.fontSize = fontSize;\n\n        // Find the maximum width of text and size the class accordingly\n        var measuredNameText = canvasContext.measureText(this.title)*2;\n        var maxWidth = Math.max(measuredNameText.width, this.width);\n        var textHeight = padding*2+fontSize*2;\n\n        // Iterate over all content text lines\n        for (var i = 0; i < this.content.length; i++) {\n            var measuredText = canvasContext.measureText(this.content[i]);\n            maxWidth = Math.max(maxWidth, measuredText.width);\n            textHeight += fontSize+padding;\n        }\n\n        if(maxWidth > this.width) {\n            this.width = maxWidth\n        }\n\n\n        // Configure drawing for shadows\n        // And generally make it look nice\n        canvasContext.shadowOffsetX = 2.0; canvasContext.shadowOffsetY = 2.0;\n\n        // Decide rect width and height\n        var rectWidth = this.width;\n        var rectHeight = Math.max(this.height, textHeight);\n\n        // Setup gradient fill\n        var grd = canvasContext.createLinearGradient(this.sx, this.sy, this.sx+rectWidth, this.sy+rectHeight);\n        grd.addColorStop(0, \"#e3895f\");\n        grd.addColorStop(1, \"#e66229\");\n\n        // Draw rect\n        canvasContext.fillStyle = grd;\n        canvasContext.fillRect(this.sx, this.sy, rectWidth, rectHeight);\n        canvasContext.strokeRect(this.sx, this.sy, rectWidth, fontSize+padding+padding);\n        canvasContext.strokeRect(this.sx, this.sy, rectWidth, rectHeight);\n\n        // Prepare to Draw nodes\n        canvasContext.fillStyle = \"#000000\";\n        canvasContext.globalAlpha = 0.6;\n\n        this.drawNode(canvasContext, this.sx, this.sy); // Top Left\n        this.drawNode(canvasContext, this.sx+rectWidth/2, this.sy); // Top\n        this.drawNode(canvasContext, this.sx+rectWidth, this.sy); // Top Right\n        this.drawNode(canvasContext, this.sx+rectWidth, this.sy+rectHeight/2); // Right\n        this.drawNode(canvasContext, this.sx+rectWidth, this.sy+rectHeight); // Bottom Right\n        this.drawNode(canvasContext, this.sx+rectWidth/2, this.sy+rectHeight); // Bottom\n        this.drawNode(canvasContext, this.sx, this.sy+rectHeight); // Bottom Left\n        this.drawNode(canvasContext, this.sx, this.sy+rectHeight/2); // Left\n\n        // Finish drawing nodes\n        canvasContext.globalAlpha = 1.0;\n\n        // Reset color for text\n        canvasContext.fillStyle = \"#000000\";\n\n        // Draw Height for text that will be increased to draw downward\n        var dy = padding+fontSize;\n\n        // Disable shadows for text\n        canvasContext.shadowOffsetX = 0.0; canvasContext.shadowOffsetY = 0.0;\n\n        // Draw name\n        canvasContext.fillText(this.title, this.sx+padding, this.sy+dy);\n        dy += padding*2 + fontSize;\n\n        // Draw text\n        for (var i = 0; i < this.content.length; i++) {\n            canvasContext.fillText(this.content[i], this.sx+padding, this.sy+dy);\n            dy += fontSize + padding;\n        }\n    }\n\n    getNodeByVertexNode(vertexNode) {\n        switch (vertexNode) {\n            case VertexNodes.TOP_LEFT:\n                return [this.sx,              this.sy,               VertexNodes.TOP_LEFT,     this];\n            case VertexNodes.TOP:\n                return [this.sx+this.width/2, this.sy,               VertexNodes.TOP,          this];\n            case VertexNodes.TOP_RIGHT:\n                return [this.sx+this.width,   this.sy,               VertexNodes.TOP_RIGHT,    this];\n            case VertexNodes.RIGHT:\n                return [this.sx+this.width,   this.sy+this.height/2, VertexNodes.RIGHT,        this];\n            case VertexNodes.BOTTOM_RIGHT:\n                return [this.sx+this.width,   this.sy+this.height,   VertexNodes.BOTTOM_RIGHT, this];\n            case VertexNodes.BOTTOM:\n                return [this.sx+this.width/2, this.sy+this.height,   VertexNodes.BOTTOM,       this];\n            case VertexNodes.BOTTOM_LEFT:\n                return [this.sx,              this.sy+this.height,   VertexNodes.BOTTOM_LEFT,  this];\n            case VertexNodes.LEFT:\n                return [this.sx,              this.sy+this.height/2, VertexNodes.LEFT,         this];\n        }\n    }\n\n    // Returns all nodes for this object\n    getNodes() {\n        var nodes = [];\n        nodes.push(this.getNodeByVertexNode(VertexNodes.TOP_LEFT));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.TOP));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.TOP_RIGHT));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.RIGHT));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM_RIGHT));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.BOTTOM_LEFT));\n        nodes.push(this.getNodeByVertexNode(VertexNodes.LEFT));\n        return nodes;\n    }\n\n    // Checks if it intersects with point\n    intersects(x, y) {\n        if (x < this.sx) return false;\n        if (y < this.sy) return false;\n        if (x > this.sx+this.width) return false;\n        if (y > this.sy+this.height) return false;\n        return true;\n    }\n}"]},"metadata":{},"sourceType":"module"}