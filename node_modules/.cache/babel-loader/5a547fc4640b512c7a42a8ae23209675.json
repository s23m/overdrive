{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\nimport { Vertex, padding } from \"../datastructures/Vertex\";\nimport { Arrow } from \"../datastructures/Arrow\"; // Core variables\n\nvar canvasElement;\nvar canvasContext; // Mouse / Cursor\n\nvar mouseStartX;\nvar mouseStartY;\nvar scrollX = 0;\nvar scrollY = 0;\nexport var mouseOriginX;\nexport var mouseOriginY; // Non zoomed in Width/Height (in pixels)\n\nvar canvasWidth;\nvar canvasHeight; // Zoom and Pan\n\nvar zoom = 200.0; // Renderable objects\n\nvar currentObjects = []; // Init\n\nexport function assignElement(elementID) {\n  canvasElement = document.getElementById(elementID);\n  canvasContext = canvasElement.getContext(\"2d\");\n  resetMouseOrigin();\n}\nexport function resetMouseOrigin() {\n  try {\n    var canvasRect = canvasElement.getBoundingClientRect();\n    mouseOriginX = canvasRect.left;\n    mouseOriginY = canvasRect.top;\n    recalculateScale();\n    clearCanvas();\n  } catch {\n    console.error(\"Failed to aquire canvas element\");\n  }\n\n  drawAll();\n} // Core functions\n\nexport function drawAll() {\n  clearCanvas();\n  canvasContext.resetTransform();\n  canvasContext.scale(getEffectiveZoom(), getEffectiveZoom());\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      item.draw(canvasContext);\n    }\n  });\n}\n\nfunction setScroll() {\n  var canvasContainerElement = document.getElementsByClassName(\"Canvas\")[0];\n  scrollX = canvasContainerElement.scrollLeft;\n  scrollY = canvasContainerElement.scrollTop;\n} // Event based functions\n\n\nexport function onMousePress(canvas, x, y) {\n  setScroll();\n  mouseStartX = x;\n  mouseStartY = y; // Enable example draw while user is deciding shape\n\n  canvasElement.onmousemove = function (e) {\n    onMouseMove(e, canvas);\n  };\n}\nexport function onMouseRelease(canvas, x, y) {\n  setScroll();\n  var newObject = createObject(canvas, mouseStartX, mouseStartY, x, y);\n  currentObjects.push(newObject); // Disable example draw\n\n  canvasElement.onmousemove = null;\n  drawAll(currentObjects);\n}\n\nfunction onMouseMove(e, canvas) {\n  setScroll();\n  var position = getGraphXYFromMouseEvent(e);\n  var x = position[0];\n  var y = position[1];\n  var newObject = createObject(canvas, mouseStartX, mouseStartY, x, y); // Redraw Existing Objects\n\n  drawAll(currentObjects); // Draw the new object\n\n  canvasContext.globalAlpha = 0.75;\n\n  if (newObject !== undefined) {\n    newObject.draw(canvasContext);\n  }\n\n  canvasContext.globalAlpha = 1.0;\n} // Zoom and pan\n\n\nexport function setZoom(newZoom) {\n  zoom = newZoom;\n  resetMouseOrigin();\n  setScroll();\n  drawAll();\n} // returns the x,y coordinates of the supplied side for the supplied vertex\n\nexport function getXYFromSide(vertex, side) {\n  var x;\n  var y;\n\n  if (side === \"north\") {\n    x = vertex.sx + vertex.width / 2 + padding;\n    y = vertex.sy;\n  } else if (side === \"east\") {\n    x = vertex.sx + vertex.width;\n    y = vertex.sy + vertex.height / 2;\n  } else if (side === \"south\") {\n    x = vertex.sx + vertex.width / 2 + padding;\n    y = vertex.sy + vertex.height;\n  } else if (side === \"west\") {\n    x = vertex.sx - padding * 2;\n    y = vertex.sy + vertex.height / 2;\n  }\n\n  return [x, y];\n} // Checks all nodes and finds the nearest node within some threshold distance\n// If no nodes are found returns null\n\nfunction findConnectable(x, y) {\n  // The maximum distance allowed for a node to be considered connectable\n  var thesholdDistance = 100; // Get nodes from all items\n  // Note: All drawable objects should include the getNodes function even if it simply returns null\n  // It should return a list, with each item formated as follows\n  // [x, y, ...]\n\n  var nodes = [];\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      var itemNodes = item.getNodes();\n\n      if (itemNodes != null) {\n        nodes = nodes.concat(itemNodes);\n      }\n    }\n  }); // If empty (because there are no nodes) return null\n\n  if (nodes.length === 0) {\n    return null;\n  } // Find closest node\n\n\n  var closestNode = nodes[0];\n  var closestDistance = getDistance(x, y, closestNode[0], closestNode[1]);\n\n  for (var i = 1; i < nodes.length; i++) {\n    var distance = getDistance(x, y, nodes[i][0], nodes[i][1]);\n\n    if (distance < closestDistance) {\n      closestNode = nodes[i];\n      closestDistance = distance;\n    }\n  } // Check if within threshold\n\n\n  if (closestDistance < thesholdDistance) {\n    return closestNode;\n  } // Exceeds threshold return null\n\n\n  return null;\n} // Gets the distance between x1, y1 and x2, y2\n\n\nexport function getDistance(x1, y1, x2, y2) {\n  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n} //returns the object with the nearest cardinal side to the given coordinates,\n// and returns that object + side if a vertex was closest\n\nfunction findNearestObjectAndSide(x, y, verticesOnly) {\n  const edges = [\"north\", \"south\", \"east\", \"west\"];\n  var nearestItem;\n  var lowestDistance = Number.MAX_VALUE;\n  var nearestEdge;\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      if (item.constructor.name === \"Vertex\") {\n        edges.forEach(edge => {\n          var coOrds = getXYFromSide(item, edge); //todo: make this solution much cleaner\n\n          var dist = Math.hypot(coOrds[0] - x * (verticesOnly ? 1 : zoom / 400), coOrds[1] - y * (verticesOnly ? 1 : zoom / 400));\n\n          if (dist < lowestDistance) {\n            lowestDistance = dist;\n            nearestItem = item;\n            nearestEdge = edge;\n          }\n        });\n      } else if (item.constructor.name === \"Arrow\") {\n        if (!verticesOnly) {\n          // find centre of the line and check distance\n          var v1 = item.fromVertex;\n          var s1 = item.fromSide;\n          var v2 = item.toVertex;\n          var s2 = item.toSide;\n          var c1 = getXYFromSide(v1, s1);\n          var c2 = getXYFromSide(v2, s2);\n          var cX = (c1[0] + c2[0]) / 2;\n          var cY = (c1[1] + c2[1]) / 2; //todo: make this solution much cleaner\n\n          var dist = Math.hypot(cX - x * zoom / 400, cY - y * zoom / 400);\n          console.log(\"VD\" + lowestDistance + \" ED\" + dist);\n          console.log(cX, cY, x, y);\n\n          if (dist < lowestDistance) {\n            lowestDistance = dist;\n            nearestItem = item;\n            nearestEdge = null;\n          }\n        }\n      }\n    }\n  });\n\n  if (nearestItem === undefined || lowestDistance >= 200) {\n    return null;\n  } else {\n    return [nearestItem, nearestEdge];\n  }\n} // Finds the object that is intersected with the cursor, returns null if no objects are intersected\n\n\nexport function findIntersected(x, y) {\n  var selectedItem = null;\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      if (item.intersects(x, y)) {\n        console.log(\"Intersection detected\");\n        console.log(item.constructor.name);\n        selectedItem = item;\n      }\n    }\n  });\n  return selectedItem;\n}\n\nfunction createObject(canvas, x1, y1, x2, y2) {\n  switch (canvas.tool) {\n    case \"Vertex\":\n      var pos = orderCoordinates(x1, y1, x2, y2);\n      return new Vertex(\"\", \"\", [\"\"], pos[0], pos[1], pos[2], pos[3]);\n\n    case \"Arrow\":\n      var fromNode = findConnectable(x1, y1);\n      var toNode = findConnectable(x2, y2);\n\n      if (fromNode !== null && toNode !== null) {\n        return new Arrow(\"\", fromNode[3], fromNode[2], toNode[3], toNode[2]);\n      } else {\n        return undefined;\n      }\n\n      exportImage();\n\n    case \"Diamond\":\n    case \"Circle\":\n    case \"Speech\":\n    case \"SpecBox\":\n    case \"Triangle\":\n    default:\n  }\n}\n\nexport function getGraphXYFromMouseEvent(e) {\n  resetMouseOrigin();\n  setScroll();\n  var x = (e.clientX - mouseOriginX) / getEffectiveZoom();\n  var y = (e.clientY - mouseOriginY) / getEffectiveZoom();\n  return [x, y];\n}\n\nfunction exportImage() {\n  var img = canvasElement.toDataURL(\"drawnCanvas.png\");\n  var element = document.createElement('canvasDownload');\n  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(\"text download\")); // TODO add download request here\n}\n\nfunction orderCoordinates(sx, sy, ex, ey) {\n  // This code also ensures x1 < x2 and y1 < y2\n  var x1 = Math.min(sx, ex);\n  var y1 = Math.min(sy, ey);\n  var x2 = Math.max(sx, ex);\n  var y2 = Math.max(sy, ey);\n  return [x1, y1, x2, y2];\n} // Gets the effective (decimal) zoom from the current zoom\n\n\nfunction getEffectiveZoom() {\n  return zoom / 100;\n} // This should be used whenever the window itself resizes\n\n\nfunction recalculateScale() {\n  // Adjusts the aspect ratio so it is 1:1 instead of matching the windows.\n  // Also removes blurry rendering\n  let dpi = window.devicePixelRatio;\n  let canvasContainer = document.getElementsByClassName(\"Canvas\")[0];\n  let styleHeight = +getComputedStyle(canvasContainer).getPropertyValue(\"height\").slice(0, -2);\n  let styleWidth = +getComputedStyle(canvasContainer).getPropertyValue(\"width\").slice(0, -2);\n  canvasElement.setAttribute('height', styleHeight * getEffectiveZoom());\n  canvasElement.setAttribute('width', styleWidth * getEffectiveZoom()); // Configurable\n\n  canvasWidth = canvasElement.width;\n  canvasHeight = canvasElement.height;\n}\n\nfunction clearCanvas() {\n  // Fill base canvas\n  canvasContext.fillStyle = \"#ffffff\";\n  canvasContext.fillRect(0, 0, canvasWidth, canvasHeight);\n}","map":{"version":3,"sources":["/ocean/pacific/University/2020/IFB398/overdrive/src/UIElements/CanvasDraw.js"],"names":["Vertex","padding","Arrow","canvasElement","canvasContext","mouseStartX","mouseStartY","scrollX","scrollY","mouseOriginX","mouseOriginY","canvasWidth","canvasHeight","zoom","currentObjects","assignElement","elementID","document","getElementById","getContext","resetMouseOrigin","canvasRect","getBoundingClientRect","left","top","recalculateScale","clearCanvas","console","error","drawAll","resetTransform","scale","getEffectiveZoom","forEach","item","undefined","draw","setScroll","canvasContainerElement","getElementsByClassName","scrollLeft","scrollTop","onMousePress","canvas","x","y","onmousemove","e","onMouseMove","onMouseRelease","newObject","createObject","push","position","getGraphXYFromMouseEvent","globalAlpha","setZoom","newZoom","getXYFromSide","vertex","side","sx","width","sy","height","findConnectable","thesholdDistance","nodes","itemNodes","getNodes","concat","length","closestNode","closestDistance","getDistance","i","distance","x1","y1","x2","y2","Math","sqrt","pow","findNearestObjectAndSide","verticesOnly","edges","nearestItem","lowestDistance","Number","MAX_VALUE","nearestEdge","constructor","name","edge","coOrds","dist","hypot","v1","fromVertex","s1","fromSide","v2","toVertex","s2","toSide","c1","c2","cX","cY","log","findIntersected","selectedItem","intersects","tool","pos","orderCoordinates","fromNode","toNode","exportImage","clientX","clientY","img","toDataURL","element","createElement","setAttribute","encodeURIComponent","ex","ey","min","max","dpi","window","devicePixelRatio","canvasContainer","styleHeight","getComputedStyle","getPropertyValue","slice","styleWidth","fillStyle","fillRect"],"mappings":"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","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {Vertex, padding} from \"../datastructures/Vertex\";\nimport {Arrow} from \"../datastructures/Arrow\";\n\n// Core variables\nvar canvasElement;\nvar canvasContext;\n\n// Mouse / Cursor\nvar mouseStartX;\nvar mouseStartY;\n\nvar scrollX = 0;\nvar scrollY = 0;\n\nexport var mouseOriginX;\nexport var mouseOriginY;\n\n// Non zoomed in Width/Height (in pixels)\nvar canvasWidth;\nvar canvasHeight;\n\n// Zoom and Pan\nvar zoom = 200.0;\n\n// Renderable objects\nvar currentObjects = [];\n\n// Init\nexport function assignElement(elementID) {\n    canvasElement = document.getElementById(elementID);\n    canvasContext =  canvasElement.getContext(\"2d\");\n\n    resetMouseOrigin();\n\n}\n\nexport function resetMouseOrigin(){\n    try {\n        var canvasRect = canvasElement.getBoundingClientRect();\n        mouseOriginX = canvasRect.left;\n        mouseOriginY = canvasRect.top;\n        recalculateScale();\n        clearCanvas();\n    }catch{\n        console.error(\"Failed to aquire canvas element\");\n    }\n    drawAll()\n}\n\n// Core functions\nexport function drawAll() {\n    clearCanvas();\n\n    canvasContext.resetTransform();\n    canvasContext.scale(getEffectiveZoom(), getEffectiveZoom());\n\n    currentObjects.forEach((item) => {\n        if (item !== undefined) {\n            item.draw(canvasContext);\n        }\n    })\n}\n\nfunction setScroll(){\n    var canvasContainerElement = document.getElementsByClassName(\"Canvas\")[0];\n    scrollX = canvasContainerElement.scrollLeft;\n    scrollY = canvasContainerElement.scrollTop;\n}\n\n// Event based functions\nexport function onMousePress(canvas, x, y) {\n    setScroll();\n    mouseStartX = x;\n    mouseStartY = y;\n\n    // Enable example draw while user is deciding shape\n    canvasElement.onmousemove = function(e) {onMouseMove(e, canvas)}\n}\n\nexport function onMouseRelease(canvas, x, y) {\n    setScroll();\n    var newObject = createObject(canvas, mouseStartX, mouseStartY, x, y)\n\n    currentObjects.push(newObject);\n\n    // Disable example draw\n    canvasElement.onmousemove = null;\n\n    drawAll(currentObjects);\n}\n\nfunction onMouseMove(e, canvas) {\n    setScroll();\n    var position = getGraphXYFromMouseEvent(e);\n    var x = position[0]; var y = position[1];\n\n    var newObject = createObject(canvas, mouseStartX, mouseStartY, x, y);\n\n    // Redraw Existing Objects\n    drawAll(currentObjects);\n\n    // Draw the new object\n    canvasContext.globalAlpha = 0.75;\n    if(newObject !== undefined) {\n        newObject.draw(canvasContext);\n    }\n    canvasContext.globalAlpha = 1.0;\n}\n\n// Zoom and pan\nexport function setZoom(newZoom) {\n    zoom = newZoom;\n\n    resetMouseOrigin();\n    setScroll();\n\n    drawAll();\n}\n\n// returns the x,y coordinates of the supplied side for the supplied vertex\nexport function getXYFromSide(vertex, side) {\n    var x;\n    var y;\n\n\n    if (side === \"north\") {\n        x = vertex.sx + (vertex.width/2)+(padding);\n        y = vertex.sy;\n    } else if (side === \"east\") {\n        x = vertex.sx + vertex.width;\n        y = vertex.sy + (vertex.height/2);\n    } else if (side === \"south\") {\n        x = vertex.sx + (vertex.width/2)+(padding);\n        y = vertex.sy + vertex.height;\n    } else if (side === \"west\") {\n        x = vertex.sx - (padding * 2);\n        y = vertex.sy + (vertex.height/2);\n    }\n\n    return [x,y]\n}\n\n// Checks all nodes and finds the nearest node within some threshold distance\n// If no nodes are found returns null\nfunction findConnectable(x, y) {\n    // The maximum distance allowed for a node to be considered connectable\n    var thesholdDistance = 100;\n\n    // Get nodes from all items\n    // Note: All drawable objects should include the getNodes function even if it simply returns null\n    // It should return a list, with each item formated as follows\n    // [x, y, ...]\n    var nodes = [];\n    currentObjects.forEach((item) => {\n        if (item !== undefined) {\n            var itemNodes = item.getNodes();\n            if (itemNodes != null) {\n                nodes = nodes.concat(itemNodes);\n            }\n        }\n    });\n\n    // If empty (because there are no nodes) return null\n    if (nodes.length === 0) {\n        return null;\n    }\n\n    // Find closest node\n    var closestNode = nodes[0];\n    var closestDistance = getDistance(x, y, closestNode[0], closestNode[1]);\n    for (var i = 1; i < nodes.length; i++) {\n        var distance = getDistance(x, y, nodes[i][0], nodes[i][1]);\n        if (distance < closestDistance) {\n            closestNode = nodes[i];\n            closestDistance = distance;\n        }\n    }\n\n    // Check if within threshold\n    if (closestDistance < thesholdDistance) {\n        return closestNode;\n    }\n\n    // Exceeds threshold return null\n    return null;\n}\n\n// Gets the distance between x1, y1 and x2, y2\nexport function getDistance(x1, y1, x2, y2) {\n    return Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));\n}\n\n\n//returns the object with the nearest cardinal side to the given coordinates,\n// and returns that object + side if a vertex was closest\nfunction findNearestObjectAndSide(x, y, verticesOnly) {\n\n    const edges = [\"north\",\"south\",\"east\",\"west\"];\n\n    var nearestItem;\n    var lowestDistance = Number.MAX_VALUE;\n    var nearestEdge;\n\n    currentObjects.forEach((item) => {\n\n        if(item !== undefined) {\n\n            if (item.constructor.name === \"Vertex\") {\n                edges.forEach((edge) => {\n\n                    var coOrds = getXYFromSide(item, edge);\n                    //todo: make this solution much cleaner\n                    var dist = Math.hypot(coOrds[0] - x * (verticesOnly ? 1 : zoom/400), coOrds[1] - y * (verticesOnly ? 1 : zoom/400));\n                    if (dist < lowestDistance) {\n                        lowestDistance = dist;\n                        nearestItem = item;\n                        nearestEdge = edge;\n                    }\n                })\n            } else if (item.constructor.name === \"Arrow\") {\n                if (!verticesOnly) {\n                    // find centre of the line and check distance\n                    var v1 = item.fromVertex;\n                    var s1 = item.fromSide;\n                    var v2 = item.toVertex;\n                    var s2 = item.toSide;\n\n                    var c1 = getXYFromSide(v1, s1);\n                    var c2 = getXYFromSide(v2, s2);\n\n                    var cX = (c1[0] + c2[0])/2;\n                    var cY = (c1[1] + c2[1])/2;\n\n                    //todo: make this solution much cleaner\n                    var dist = Math.hypot(cX - x*zoom/400, cY - y*zoom/400);\n                    console.log(\"VD\" + lowestDistance + \" ED\" + dist)\n                    console.log(cX,cY,x,y)\n                    if (dist < lowestDistance) {\n                        lowestDistance = dist;\n                        nearestItem = item;\n                        nearestEdge = null;\n                    }\n                }\n            }\n        }\n    });\n  \n    if (nearestItem === undefined || lowestDistance >= 200) {\n        return null\n    } else {\n        return [nearestItem, nearestEdge];\n    }\n}\n\n// Finds the object that is intersected with the cursor, returns null if no objects are intersected\nexport function findIntersected(x, y) {\n    var selectedItem = null;\n    currentObjects.forEach((item) => {\n        if(item !== undefined) {\n            if (item.intersects(x, y)) {\n                console.log(\"Intersection detected\");\n                console.log(item.constructor.name);\n                selectedItem = item;\n            }\n        }\n    });\n    return selectedItem;\n}\n\nfunction createObject(canvas, x1, y1, x2, y2) {\n    switch(canvas.tool) {\n        case \"Vertex\":\n            var pos = orderCoordinates(x1, y1, x2, y2);\n            return new Vertex(\"\",\"\",[\"\"], pos[0], pos[1], pos[2], pos[3]);\n        case \"Arrow\":\n            var fromNode = findConnectable(x1, y1);\n            var toNode   = findConnectable(x2, y2);\n\n            if (fromNode !== null && toNode !== null) {\n                return new Arrow(\"\", fromNode[3], fromNode[2], toNode[3], toNode[2]);\n            } else {\n                return undefined;\n            }\n            exportImage();\n        case \"Diamond\":\n        case \"Circle\":\n        case \"Speech\":\n        case \"SpecBox\":\n        case \"Triangle\":\n        default:\n    }\n}\n\nexport function getGraphXYFromMouseEvent(e) {\n    resetMouseOrigin();\n    setScroll();\n\n    var x = (e.clientX-mouseOriginX)/getEffectiveZoom();\n    var y = (e.clientY-mouseOriginY)/getEffectiveZoom();\n\n    return [x, y];\n}\n\nfunction exportImage() {\n    var img = canvasElement.toDataURL(\"drawnCanvas.png\");\n\n    var element = document.createElement('canvasDownload');\n    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(\"text download\"));\n    // TODO add download request here\n}\n\nfunction orderCoordinates(sx, sy, ex, ey) {\n    // This code also ensures x1 < x2 and y1 < y2\n    var x1 = Math.min(sx, ex);\n    var y1 = Math.min(sy, ey);\n    var x2 = Math.max(sx, ex);\n    var y2 = Math.max(sy, ey);\n\n    return [x1, y1, x2, y2];\n}\n\n// Gets the effective (decimal) zoom from the current zoom\nfunction getEffectiveZoom() {\n    return zoom/100;\n}\n\n// This should be used whenever the window itself resizes\nfunction recalculateScale() {\n    // Adjusts the aspect ratio so it is 1:1 instead of matching the windows.\n    // Also removes blurry rendering\n    let dpi = window.devicePixelRatio;\n    let canvasContainer = document.getElementsByClassName(\"Canvas\")[0]\n    let styleHeight = +getComputedStyle(canvasContainer).getPropertyValue(\"height\").slice(0, -2);\n    let styleWidth = +getComputedStyle(canvasContainer).getPropertyValue(\"width\").slice(0, -2);\n\n    canvasElement.setAttribute('height', styleHeight * getEffectiveZoom());\n    canvasElement.setAttribute('width', styleWidth * getEffectiveZoom());\n\n    // Configurable\n    canvasWidth = canvasElement.width;\n    canvasHeight = canvasElement.height;\n}\n\nfunction clearCanvas() {\n     // Fill base canvas\n    canvasContext.fillStyle = \"#ffffff\";\n    canvasContext.fillRect(0, 0, canvasWidth, canvasHeight);\n}\n"]},"metadata":{},"sourceType":"module"}