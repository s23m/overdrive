{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\nimport { Vertex, padding } from \"../DataStructures/Vertex\";\nimport { Arrow } from \"../DataStructures/Arrow\"; // Core variables\n\nvar canvasElement;\nvar canvasContext; // Mouse / Cursor\n\nvar mouseStartX;\nvar mouseStartY;\nvar scrollX = 0;\nvar scrollY = 0; //todo: make this selectable by the user\n\nconst yRows = 35;\nexport var mouseOriginX;\nexport var mouseOriginY; // Non zoomed in Width/Height (in pixels)\n\nvar canvasWidth;\nvar canvasHeight; // Zoom and Pan\n\nvar zoom = 200.0; // Renderable objects\n\nvar currentObjects = []; // Init\n\nexport function assignElement(elementID) {\n  canvasElement = document.getElementById(elementID);\n  canvasContext = canvasElement.getContext(\"2d\");\n  resetMouseOrigin();\n}\nexport function resetMouseOrigin() {\n  try {\n    var canvasRect = canvasElement.getBoundingClientRect();\n    mouseOriginX = canvasRect.left;\n    mouseOriginY = canvasRect.top;\n    recalculateScale();\n    clearCanvas();\n  } catch {\n    console.error(\"Failed to aquire canvas element\");\n  }\n\n  drawAll();\n}\n\nfunction drawLine(x0, y0, x1, y1, color) {\n  canvasContext.beginPath();\n  canvasContext.strokeStyle = color;\n  canvasContext.moveTo(x0, y0);\n  canvasContext.lineTo(x1, y1);\n  canvasContext.stroke();\n  canvasContext.strokeStyle = \"#000000\";\n} // Core functions\n\n\nexport function drawAll() {\n  clearCanvas();\n  canvasContext.resetTransform();\n  canvasContext.scale(getEffectiveZoom(), getEffectiveZoom());\n  var rowHeight = 200;\n\n  for (let i = 0; i < canvasHeight; i += canvasHeight / yRows / 2) {\n    let y1 = findNearestGridY(i, 1);\n    let y2 = findNearestGridY(i, 0);\n    drawLine(0, y1, canvasWidth, y1, \"#D0D0D0\");\n    drawLine(0, y2, canvasWidth, y2, \"#E0E0E0\");\n  }\n\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      item.draw(canvasContext);\n    }\n  });\n}\n\nfunction setScroll() {\n  var canvasContainerElement = document.getElementsByClassName(\"Canvas\")[0];\n  scrollX = canvasContainerElement.scrollLeft;\n  scrollY = canvasContainerElement.scrollTop;\n} // format co-ordinate so that the value aligns with a row\n\n\nfunction findNearestGridY(y, top) {\n  // distance to topmost top rowLine\n  let slotHeight = canvasHeight / yRows; // which row to put it in\n\n  let slot = Math.floor(y / slotHeight); // y co-ordinate of that row (if bottom then go up by row gap)\n\n  return slotHeight * slot + slotHeight / 2 * +top;\n} // Event based functions\n\n\nexport function onMousePress(canvas, x, y) {\n  setScroll();\n  mouseStartX = x;\n  mouseStartY = findNearestGridY(y, 1); // Enable example draw while user is deciding shape\n\n  canvasElement.onmousemove = function (e) {\n    onMouseMove(e, canvas);\n  };\n}\nexport function onMouseRelease(canvas, x, y) {\n  setScroll();\n  var newObject = createObject(canvas, mouseStartX, mouseStartY, x, findNearestGridY(y, 0));\n  currentObjects.push(newObject);\n\n  if (newObject.constructor.name === \"Arrow\") {\n    newObject.bindNodes();\n  } // Disable example draw\n\n\n  canvasElement.onmousemove = null;\n  drawAll(currentObjects);\n}\n\nfunction onMouseMove(e, canvas) {\n  setScroll();\n  var position = getGraphXYFromMouseEvent(e);\n  var x = position[0];\n  var y = findNearestGridY(position[1], 0);\n  var newObject = createObject(canvas, mouseStartX, mouseStartY, x, y); // Redraw Existing Objects\n\n  drawAll(currentObjects); // Draw the new object\n\n  canvasContext.globalAlpha = 0.75;\n\n  if (newObject !== undefined) {\n    newObject.draw(canvasContext);\n  }\n\n  canvasContext.globalAlpha = 1.0;\n} // Zoom and pan\n\n\nexport function setZoom(newZoom) {\n  zoom = newZoom;\n  resetMouseOrigin();\n  setScroll();\n  drawAll();\n} // returns the x,y coordinates of the supplied side for the supplied vertex\n\nexport function getXYFromSide(vertex, side) {\n  var x;\n  var y;\n\n  if (side === \"north\") {\n    x = vertex.sx + vertex.width / 2 + padding;\n    y = vertex.sy;\n  } else if (side === \"east\") {\n    x = vertex.sx + vertex.width;\n    y = vertex.sy + vertex.height / 2;\n  } else if (side === \"south\") {\n    x = vertex.sx + vertex.width / 2 + padding;\n    y = vertex.sy + vertex.height;\n  } else if (side === \"west\") {\n    x = vertex.sx - padding * 2;\n    y = vertex.sy + vertex.height / 2;\n  }\n\n  return [x, y];\n} // Checks all nodes and finds the nearest node within some threshold distance\n// If no nodes are found returns null\n\nfunction findConnectable(x, y) {\n  // The maximum distance allowed for a node to be considered connectable\n  var thesholdDistance = 100; // Get nodes from all items\n  // Note: All drawable objects should include the getNodes function even if it simply returns null\n  // It should return a list, with each item formated as follows\n  // [x, y, ...]\n\n  var nodes = [];\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      var itemNodes = item.getNodes();\n\n      if (itemNodes != null) {\n        nodes = nodes.concat(itemNodes);\n      }\n    }\n  }); // If empty (because there are no nodes) return null\n\n  if (nodes.length === 0) {\n    return null;\n  } // Find closest node\n\n\n  var closestNode = nodes[0];\n  var closestDistance = getDistance(x, y, closestNode[0], closestNode[1]);\n\n  for (var i = 1; i < nodes.length; i++) {\n    var distance = getDistance(x, y, nodes[i][0], nodes[i][1]);\n\n    if (distance < closestDistance) {\n      closestNode = nodes[i];\n      closestDistance = distance;\n    }\n  } // Check if within threshold\n\n\n  if (closestDistance < thesholdDistance) {\n    return closestNode;\n  } // Exceeds threshold return null\n\n\n  return null;\n} // Gets the distance between x1, y1 and x2, y2\n\n\nexport function getDistance(x1, y1, x2, y2) {\n  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n} //returns the object with the nearest cardinal side to the given coordinates,\n// and returns that object + side if a vertex was closest\n\nfunction findNearestObjectAndSide(x, y, verticesOnly) {\n  const edges = [\"north\", \"south\", \"east\", \"west\"];\n  var nearestItem;\n  var lowestDistance = Number.MAX_VALUE;\n  var nearestEdge;\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      if (item.constructor.name === \"Vertex\") {\n        edges.forEach(edge => {\n          var coOrds = getXYFromSide(item, edge); //todo: make this solution much cleaner\n\n          var dist = Math.hypot(coOrds[0] - x * (verticesOnly ? 1 : zoom / 400), coOrds[1] - y * (verticesOnly ? 1 : zoom / 400));\n\n          if (dist < lowestDistance) {\n            lowestDistance = dist;\n            nearestItem = item;\n            nearestEdge = edge;\n          }\n        });\n      } else if (item.constructor.name === \"Arrow\") {\n        if (!verticesOnly) {\n          // find centre of the line and check distance\n          var v1 = item.fromVertex;\n          var s1 = item.fromSide;\n          var v2 = item.toVertex;\n          var s2 = item.toSide;\n          var c1 = getXYFromSide(v1, s1);\n          var c2 = getXYFromSide(v2, s2);\n          var cX = (c1[0] + c2[0]) / 2;\n          var cY = (c1[1] + c2[1]) / 2; //todo: make this solution much cleaner\n\n          var dist = Math.hypot(cX - x * zoom / 400, cY - y * zoom / 400);\n          console.log(\"VD\" + lowestDistance + \" ED\" + dist);\n          console.log(cX, cY, x, y);\n\n          if (dist < lowestDistance) {\n            lowestDistance = dist;\n            nearestItem = item;\n            nearestEdge = null;\n          }\n        }\n      }\n    }\n  });\n\n  if (nearestItem === undefined || lowestDistance >= 200) {\n    return null;\n  } else {\n    return [nearestItem, nearestEdge];\n  }\n} // Finds the object that is intersected with the cursor, returns null if no objects are intersected\n\n\nexport function findIntersected(x, y) {\n  var selectedItem = null;\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      if (item.intersects(x, y)) {\n        console.log(\"Intersection detected\");\n        console.log(item.constructor.name);\n        selectedItem = item;\n      }\n    }\n  });\n  return selectedItem;\n}\n\nfunction createObject(canvas, x1, y1, x2, y2) {\n  switch (canvas.tool) {\n    case \"Vertex\":\n      var pos = orderCoordinates(x1, y1, x2, y2);\n      return new Vertex(\"\", \"\", [\"\"], pos[0], pos[1], pos[2], pos[3]);\n\n    case \"Arrow\":\n      var fromNode = findConnectable(x1, y1);\n      var toNode = findConnectable(x2, y2);\n\n      if (fromNode !== null && toNode !== null) {\n        getDownload();\n        return new Arrow(\"\", fromNode[3], fromNode[2], toNode[3], toNode[2]);\n      } else {\n        return undefined;\n      }\n\n    case \"Diamond\":\n    case \"Circle\":\n    case \"Speech\":\n    case \"SpecBox\":\n    case \"Triangle\":\n    default:\n  }\n}\n\nexport function getGraphXYFromMouseEvent(e) {\n  resetMouseOrigin();\n  setScroll();\n  var x = (e.clientX - mouseOriginX) / getEffectiveZoom();\n  var y = (e.clientY - mouseOriginY) / getEffectiveZoom();\n  return [x, y];\n}\n\nfunction exportImage() {\n  getDownload();\n}\n\nexport function getDownload() {\n  document.getElementById(\"downloader\").download = \"image.png\";\n  document.getElementById(\"downloader\").href = canvasElement.toDataURL(\"image/png\").replace(/^data:image\\/[^;]/, 'data:application/octet-stream');\n}\n\nfunction orderCoordinates(sx, sy, ex, ey) {\n  // This code also ensures x1 < x2 and y1 < y2\n  var x1 = Math.min(sx, ex);\n  var y1 = Math.min(sy, ey);\n  var x2 = Math.max(sx, ex);\n  var y2 = Math.max(sy, ey);\n  return [x1, y1, x2, y2];\n} // Gets the effective (decimal) zoom from the current zoom\n\n\nfunction getEffectiveZoom() {\n  return zoom / 100;\n} // This should be used whenever the window itself resizes\n\n\nfunction recalculateScale() {\n  // Adjusts the aspect ratio so it is 1:1 instead of matching the windows.\n  // Also removes blurry rendering\n  let dpi = window.devicePixelRatio;\n  let canvasContainer = document.getElementsByClassName(\"Canvas\")[0];\n  let styleHeight = +getComputedStyle(canvasContainer).getPropertyValue(\"height\").slice(0, -2);\n  let styleWidth = +getComputedStyle(canvasContainer).getPropertyValue(\"width\").slice(0, -2);\n  canvasElement.setAttribute('height', styleHeight * getEffectiveZoom());\n  canvasElement.setAttribute('width', styleWidth * getEffectiveZoom()); // Configurable\n\n  canvasWidth = canvasElement.width;\n  canvasHeight = canvasElement.height;\n}\n\nfunction clearCanvas() {\n  // Fill base canvas\n  canvasContext.fillStyle = \"#ffffff\";\n  canvasContext.fillRect(0, 0, canvasWidth, canvasHeight);\n}","map":{"version":3,"sources":["/ocean/pacific/University/2020/IFB398/overdrive/src/UIElements/CanvasDraw.js"],"names":["Vertex","padding","Arrow","canvasElement","canvasContext","mouseStartX","mouseStartY","scrollX","scrollY","yRows","mouseOriginX","mouseOriginY","canvasWidth","canvasHeight","zoom","currentObjects","assignElement","elementID","document","getElementById","getContext","resetMouseOrigin","canvasRect","getBoundingClientRect","left","top","recalculateScale","clearCanvas","console","error","drawAll","drawLine","x0","y0","x1","y1","color","beginPath","strokeStyle","moveTo","lineTo","stroke","resetTransform","scale","getEffectiveZoom","rowHeight","i","findNearestGridY","y2","forEach","item","undefined","draw","setScroll","canvasContainerElement","getElementsByClassName","scrollLeft","scrollTop","y","slotHeight","slot","Math","floor","onMousePress","canvas","x","onmousemove","e","onMouseMove","onMouseRelease","newObject","createObject","push","constructor","name","bindNodes","position","getGraphXYFromMouseEvent","globalAlpha","setZoom","newZoom","getXYFromSide","vertex","side","sx","width","sy","height","findConnectable","thesholdDistance","nodes","itemNodes","getNodes","concat","length","closestNode","closestDistance","getDistance","distance","x2","sqrt","pow","findNearestObjectAndSide","verticesOnly","edges","nearestItem","lowestDistance","Number","MAX_VALUE","nearestEdge","edge","coOrds","dist","hypot","v1","fromVertex","s1","fromSide","v2","toVertex","s2","toSide","c1","c2","cX","cY","log","findIntersected","selectedItem","intersects","tool","pos","orderCoordinates","fromNode","toNode","getDownload","clientX","clientY","exportImage","download","href","toDataURL","replace","ex","ey","min","max","dpi","window","devicePixelRatio","canvasContainer","styleHeight","getComputedStyle","getPropertyValue","slice","styleWidth","setAttribute","fillStyle","fillRect"],"mappings":"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","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {Vertex, padding} from \"../DataStructures/Vertex\";\nimport {Arrow} from \"../DataStructures/Arrow\";\n\n// Core variables\nvar canvasElement;\nvar canvasContext;\n\n// Mouse / Cursor\nvar mouseStartX;\nvar mouseStartY;\n\nvar scrollX = 0;\nvar scrollY = 0;\n\n//todo: make this selectable by the user\nconst yRows = 35;\n\nexport var mouseOriginX;\nexport var mouseOriginY;\n\n// Non zoomed in Width/Height (in pixels)\nvar canvasWidth;\nvar canvasHeight;\n\n// Zoom and Pan\nvar zoom = 200.0;\n\n// Renderable objects\nvar currentObjects = [];\n\n// Init\nexport function assignElement(elementID) {\n    canvasElement = document.getElementById(elementID);\n    canvasContext =  canvasElement.getContext(\"2d\");\n\n    resetMouseOrigin();\n\n}\n\nexport function resetMouseOrigin(){\n    try {\n        var canvasRect = canvasElement.getBoundingClientRect();\n        mouseOriginX = canvasRect.left;\n        mouseOriginY = canvasRect.top;\n        recalculateScale();\n        clearCanvas();\n    }catch{\n        console.error(\"Failed to aquire canvas element\");\n    }\n    drawAll()\n}\n\nfunction drawLine(x0,y0,x1,y1,color) {\n    canvasContext.beginPath();\n    canvasContext.strokeStyle = color;\n    canvasContext.moveTo(x0,y0);\n    canvasContext.lineTo(x1,y1);\n    canvasContext.stroke();\n    canvasContext.strokeStyle = \"#000000\"\n}\n\n// Core functions\nexport function drawAll() {\n    clearCanvas();\n\n    canvasContext.resetTransform();\n    canvasContext.scale(getEffectiveZoom(), getEffectiveZoom());\n\n    var rowHeight = 200;\n\n    for (let i = 0; i < canvasHeight; i+= canvasHeight/yRows/2) {\n        let y1 = findNearestGridY(i,1);\n        let y2 = findNearestGridY(i,0);\n        drawLine(0,y1,canvasWidth,y1,\"#D0D0D0\");\n        drawLine(0,y2,canvasWidth,y2,\"#E0E0E0\");\n    }\n\n    currentObjects.forEach((item) => {\n        if (item !== undefined) {\n            item.draw(canvasContext);\n        }\n    })\n}\n\nfunction setScroll(){\n    var canvasContainerElement = document.getElementsByClassName(\"Canvas\")[0];\n    scrollX = canvasContainerElement.scrollLeft;\n    scrollY = canvasContainerElement.scrollTop;\n}\n\n// format co-ordinate so that the value aligns with a row\nfunction findNearestGridY(y,top){\n\n    // distance to topmost top rowLine\n    let slotHeight = (canvasHeight)/ yRows;\n\n    // which row to put it in\n    let slot = Math.floor(y/slotHeight);\n\n    // y co-ordinate of that row (if bottom then go up by row gap)\n    return slotHeight * slot + (slotHeight/2 * + top)\n}\n\n// Event based functions\nexport function onMousePress(canvas, x, y) {\n    setScroll();\n    mouseStartX = x;\n    mouseStartY = findNearestGridY(y,1);\n\n    // Enable example draw while user is deciding shape\n    canvasElement.onmousemove = function(e) {onMouseMove(e, canvas)}\n}\n\nexport function onMouseRelease(canvas, x, y) {\n    setScroll();\n    var newObject = createObject(canvas, mouseStartX, mouseStartY, x, findNearestGridY(y,0))\n\n    currentObjects.push(newObject);\n\n    if(newObject.constructor.name === \"Arrow\"){\n        newObject.bindNodes()\n    }\n\n    // Disable example draw\n    canvasElement.onmousemove = null;\n\n    drawAll(currentObjects);\n}\n\nfunction onMouseMove(e, canvas) {\n    setScroll();\n    var position = getGraphXYFromMouseEvent(e);\n    var x = position[0]; var y = findNearestGridY(position[1],0);\n\n    var newObject = createObject(canvas, mouseStartX, mouseStartY, x, y);\n\n    // Redraw Existing Objects\n    drawAll(currentObjects);\n\n    // Draw the new object\n    canvasContext.globalAlpha = 0.75;\n    if(newObject !== undefined) {\n        newObject.draw(canvasContext);\n    }\n    canvasContext.globalAlpha = 1.0;\n}\n\n// Zoom and pan\nexport function setZoom(newZoom) {\n    zoom = newZoom;\n\n    resetMouseOrigin();\n    setScroll();\n\n    drawAll();\n}\n\n// returns the x,y coordinates of the supplied side for the supplied vertex\nexport function getXYFromSide(vertex, side) {\n    var x;\n    var y;\n\n\n    if (side === \"north\") {\n        x = vertex.sx + (vertex.width/2)+(padding);\n        y = vertex.sy;\n    } else if (side === \"east\") {\n        x = vertex.sx + vertex.width;\n        y = vertex.sy + (vertex.height/2);\n    } else if (side === \"south\") {\n        x = vertex.sx + (vertex.width/2)+(padding);\n        y = vertex.sy + vertex.height;\n    } else if (side === \"west\") {\n        x = vertex.sx - (padding * 2);\n        y = vertex.sy + (vertex.height/2);\n    }\n\n    return [x,y]\n}\n\n// Checks all nodes and finds the nearest node within some threshold distance\n// If no nodes are found returns null\nfunction findConnectable(x, y) {\n    // The maximum distance allowed for a node to be considered connectable\n    var thesholdDistance = 100;\n\n    // Get nodes from all items\n    // Note: All drawable objects should include the getNodes function even if it simply returns null\n    // It should return a list, with each item formated as follows\n    // [x, y, ...]\n    var nodes = [];\n    currentObjects.forEach((item) => {\n        if (item !== undefined) {\n            var itemNodes = item.getNodes();\n            if (itemNodes != null) {\n                nodes = nodes.concat(itemNodes);\n            }\n        }\n    });\n\n    // If empty (because there are no nodes) return null\n    if (nodes.length === 0) {\n        return null;\n    }\n\n    // Find closest node\n    var closestNode = nodes[0];\n    var closestDistance = getDistance(x, y, closestNode[0], closestNode[1]);\n    for (var i = 1; i < nodes.length; i++) {\n        var distance = getDistance(x, y, nodes[i][0], nodes[i][1]);\n        if (distance < closestDistance) {\n            closestNode = nodes[i];\n            closestDistance = distance;\n        }\n    }\n\n    // Check if within threshold\n    if (closestDistance < thesholdDistance) {\n        return closestNode;\n    }\n\n    // Exceeds threshold return null\n    return null;\n}\n\n// Gets the distance between x1, y1 and x2, y2\nexport function getDistance(x1, y1, x2, y2) {\n    return Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));\n}\n\n\n//returns the object with the nearest cardinal side to the given coordinates,\n// and returns that object + side if a vertex was closest\nfunction findNearestObjectAndSide(x, y, verticesOnly) {\n\n    const edges = [\"north\",\"south\",\"east\",\"west\"];\n\n    var nearestItem;\n    var lowestDistance = Number.MAX_VALUE;\n    var nearestEdge;\n\n    currentObjects.forEach((item) => {\n\n        if(item !== undefined) {\n\n            if (item.constructor.name === \"Vertex\") {\n                edges.forEach((edge) => {\n\n                    var coOrds = getXYFromSide(item, edge);\n                    //todo: make this solution much cleaner\n                    var dist = Math.hypot(coOrds[0] - x * (verticesOnly ? 1 : zoom/400), coOrds[1] - y * (verticesOnly ? 1 : zoom/400));\n                    if (dist < lowestDistance) {\n                        lowestDistance = dist;\n                        nearestItem = item;\n                        nearestEdge = edge;\n                    }\n                })\n            } else if (item.constructor.name === \"Arrow\") {\n                if (!verticesOnly) {\n                    // find centre of the line and check distance\n                    var v1 = item.fromVertex;\n                    var s1 = item.fromSide;\n                    var v2 = item.toVertex;\n                    var s2 = item.toSide;\n\n                    var c1 = getXYFromSide(v1, s1);\n                    var c2 = getXYFromSide(v2, s2);\n\n                    var cX = (c1[0] + c2[0])/2;\n                    var cY = (c1[1] + c2[1])/2;\n\n                    //todo: make this solution much cleaner\n                    var dist = Math.hypot(cX - x*zoom/400, cY - y*zoom/400);\n                    console.log(\"VD\" + lowestDistance + \" ED\" + dist)\n                    console.log(cX,cY,x,y)\n                    if (dist < lowestDistance) {\n                        lowestDistance = dist;\n                        nearestItem = item;\n                        nearestEdge = null;\n                    }\n                }\n            }\n        }\n    });\n  \n    if (nearestItem === undefined || lowestDistance >= 200) {\n        return null\n    } else {\n        return [nearestItem, nearestEdge];\n    }\n}\n\n// Finds the object that is intersected with the cursor, returns null if no objects are intersected\nexport function findIntersected(x, y) {\n    var selectedItem = null;\n    currentObjects.forEach((item) => {\n        if(item !== undefined) {\n            if (item.intersects(x, y)) {\n                console.log(\"Intersection detected\");\n                console.log(item.constructor.name);\n                selectedItem = item;\n            }\n        }\n    });\n    return selectedItem;\n}\n\nfunction createObject(canvas, x1, y1, x2, y2) {\n    switch(canvas.tool) {\n        case \"Vertex\":\n            var pos = orderCoordinates(x1, y1, x2, y2);\n            return new Vertex(\"\",\"\",[\"\"], pos[0], pos[1], pos[2], pos[3]);\n        case \"Arrow\":\n            var fromNode = findConnectable(x1, y1);\n            var toNode   = findConnectable(x2, y2);\n\n            if (fromNode !== null && toNode !== null) {\n                getDownload();\n                return new Arrow(\"\", fromNode[3], fromNode[2], toNode[3], toNode[2]);\n            } else {\n                return undefined;\n            }\n        case \"Diamond\":\n        case \"Circle\":\n        case \"Speech\":\n        case \"SpecBox\":\n        case \"Triangle\":\n        default:\n    }\n}\n\nexport function getGraphXYFromMouseEvent(e) {\n    resetMouseOrigin();\n    setScroll();\n\n    var x = (e.clientX-mouseOriginX)/getEffectiveZoom();\n    var y = (e.clientY-mouseOriginY)/getEffectiveZoom();\n\n    return [x, y];\n}\n\nfunction exportImage() {\n    getDownload();\n}\n\nexport function getDownload() {\n    document.getElementById(\"downloader\").download = \"image.png\";\n    document.getElementById(\"downloader\").href = canvasElement.toDataURL(\"image/png\").replace(/^data:image\\/[^;]/, 'data:application/octet-stream');\n}\n\nfunction orderCoordinates(sx, sy, ex, ey) {\n    // This code also ensures x1 < x2 and y1 < y2\n    var x1 = Math.min(sx, ex);\n    var y1 = Math.min(sy, ey);\n    var x2 = Math.max(sx, ex);\n    var y2 = Math.max(sy, ey);\n\n    return [x1, y1, x2, y2];\n}\n\n// Gets the effective (decimal) zoom from the current zoom\nfunction getEffectiveZoom() {\n    return zoom/100;\n}\n\n// This should be used whenever the window itself resizes\nfunction recalculateScale() {\n    // Adjusts the aspect ratio so it is 1:1 instead of matching the windows.\n    // Also removes blurry rendering\n    let dpi = window.devicePixelRatio;\n    let canvasContainer = document.getElementsByClassName(\"Canvas\")[0]\n    let styleHeight = +getComputedStyle(canvasContainer).getPropertyValue(\"height\").slice(0, -2);\n    let styleWidth = +getComputedStyle(canvasContainer).getPropertyValue(\"width\").slice(0, -2);\n\n    canvasElement.setAttribute('height', styleHeight * getEffectiveZoom());\n    canvasElement.setAttribute('width', styleWidth * getEffectiveZoom());\n\n    // Configurable\n    canvasWidth = canvasElement.width;\n    canvasHeight = canvasElement.height;\n}\n\nfunction clearCanvas() {\n     // Fill base canvas\n    canvasContext.fillStyle = \"#ffffff\";\n    canvasContext.fillRect(0, 0, canvasWidth, canvasHeight);\n}\n"]},"metadata":{},"sourceType":"module"}