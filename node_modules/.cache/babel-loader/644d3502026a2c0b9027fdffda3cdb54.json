{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\nimport { Vertex, padding } from \"../DataStructures/Vertex\";\nimport { Arrow } from \"../DataStructures/Arrow\"; // Core variables\n\nvar canvasElement;\nvar canvasContext; // Mouse / Cursor\n\nvar mouseStartX;\nvar mouseStartY;\nvar scrollX = 0;\nvar scrollY = 0; //todo: make this selectable by the user\n\nconst yRows = 35;\nexport var mouseOriginX;\nexport var mouseOriginY; // Non zoomed in Width/Height (in pixels)\n\nvar canvasWidth;\nvar canvasHeight; // Zoom and Pan\n\nvar zoom = 200.0; // Renderable objects\n\nvar currentObjects = [];\nvar resizing = false; // Init\n\nexport function assignElement(elementID) {\n  canvasElement = document.getElementById(elementID);\n  canvasContext = canvasElement.getContext(\"2d\");\n  resetMouseOrigin();\n}\nexport function resetMouseOrigin() {\n  try {\n    var canvasRect = canvasElement.getBoundingClientRect();\n    mouseOriginX = canvasRect.left;\n    mouseOriginY = canvasRect.top;\n    recalculateScale();\n    clearCanvas();\n  } catch {\n    console.error(\"Failed to aquire canvas element\");\n  }\n\n  drawAll();\n}\n\nfunction drawLine(x0, y0, x1, y1, color) {\n  canvasContext.beginPath();\n  canvasContext.strokeStyle = color;\n  canvasContext.moveTo(x0, y0);\n  canvasContext.lineTo(x1, y1);\n  canvasContext.stroke();\n  canvasContext.strokeStyle = \"#000000\";\n} // Core functions\n\n\nexport function drawAll() {\n  clearCanvas();\n  canvasContext.resetTransform();\n  canvasContext.scale(getEffectiveZoom(), getEffectiveZoom());\n\n  for (let i = 0; i < canvasHeight; i += canvasHeight / yRows / 2) {\n    let y1 = findNearestGridY(i, 1);\n    let y2 = findNearestGridY(i, 0);\n    drawLine(0, y1, canvasWidth, y1, \"#D0D0D0\");\n    drawLine(0, y2, canvasWidth, y2, \"#E0E0E0\");\n  }\n\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      item.draw(canvasContext);\n    }\n  });\n}\n\nfunction setScroll() {\n  var canvasContainerElement = document.getElementsByClassName(\"Canvas\")[0];\n  scrollX = canvasContainerElement.scrollLeft;\n  scrollY = canvasContainerElement.scrollTop;\n} // format co-ordinate so that the value aligns with a row\n\n\nfunction findNearestGridY(y, top) {\n  // distance to topmost top rowLine\n  let slotHeight = 25 * zoom / 100 * 200 / zoom; // which row to put it in\n\n  let slot = Math.floor(y / slotHeight); // y co-ordinate of that row (if bottom then go up by row gap)\n\n  return slotHeight * slot + slotHeight / 2 * +top;\n}\n\nfunction checkResizeBounds(x, y) {\n  let vertex = null;\n  let side = null;\n  currentObjects.forEach(item => {\n    if (item.constructor.name === \"Vertex\") {\n      let bounds = item.getBounds();\n      let x1 = bounds[0];\n      let y1 = bounds[1];\n      let x2 = bounds[2];\n      let y2 = bounds[3];\n      let top = Math.abs(y1 - y) < 10;\n      let bottom = Math.abs(y2 - y) < 10;\n      let left = Math.abs(x1 - x) < 10;\n      let right = Math.abs(x2 - x) < 10;\n      let inYbounds = y > y1 && y < y2;\n      let inXbounds = x > x1 && x < x2;\n\n      if (top && left) {\n        vertex = item;\n        side = \"topLeft\";\n      } else if (top && right) {\n        vertex = item;\n        side = \"topRight\";\n      } else if (bottom && left) {\n        vertex = item;\n        side = \"bottomLeft\";\n      } else if (bottom && right) {\n        vertex = item;\n        side = \"bottomRight\";\n      } else if (left && inYbounds) {\n        vertex = item;\n        side = \"left\";\n      } else if (right && inYbounds) {\n        vertex = item;\n        side = \"right\";\n      } else if (top && inXbounds) {\n        vertex = item;\n        side = \"top\";\n      } else if (bottom && inXbounds) {\n        vertex = item;\n        side = \"bottom\";\n      }\n    }\n  });\n  return [vertex, side];\n}\n\nfunction resizeObjectOnMouseMove(e, resizeVars) {\n  let coOrds = getGraphXYFromMouseEvent(e);\n  resizeVars[0].expandSide(resizeVars[1], coOrds[0], coOrds[1]);\n} // Event based functions\n\n\nexport function onMousePress(canvas, x, y) {\n  let resizeVars = checkResizeBounds(x, y);\n\n  if (canvas.tool === \"Vertex\") {\n    if (resizeVars[0] !== null) {\n      resizing = true;\n\n      canvasElement.onmousemove = function (e) {\n        resizeObjectOnMouseMove(e, resizeVars);\n      };\n\n      return;\n    }\n  }\n\n  setScroll();\n  mouseStartX = x;\n  mouseStartY = findNearestGridY(y, 1); // Enable example draw while user is deciding shape\n\n  canvasElement.onmousemove = function (e) {\n    onMouseMove(e, canvas);\n  };\n}\nexport function onMouseRelease(canvas, x, y) {\n  if (resizing === true) {\n    resizing = false;\n    canvasElement.onmousemove = null;\n    return;\n  }\n\n  setScroll();\n  var newObject = createObject(canvas, mouseStartX, mouseStartY, x, findNearestGridY(y, 0));\n  currentObjects.push(newObject);\n\n  if (newObject.constructor.name === \"Arrow\") {\n    newObject.bindNodes();\n  } // Disable example draw\n\n\n  canvasElement.onmousemove = null;\n  drawAll(currentObjects);\n}\n\nfunction onMouseMove(e, canvas) {\n  setScroll();\n  var position = getGraphXYFromMouseEvent(e);\n  var x = position[0];\n  var y = findNearestGridY(position[1], 0);\n  var newObject = createObject(canvas, mouseStartX, mouseStartY, x, y); // Redraw Existing Objects\n\n  drawAll(currentObjects); // Draw the new object\n\n  canvasContext.globalAlpha = 0.75;\n\n  if (newObject !== undefined) {\n    newObject.draw(canvasContext);\n  }\n\n  canvasContext.globalAlpha = 1.0;\n}\n\nexport function onMiddleClick(canvas, x, y) {\n  console.log(\"Moving Object\");\n  let selectedObject = findIntersected(x, y);\n\n  canvasElement.onmousemove = function (e) {\n    moveObject(e, selectedObject);\n  };\n}\n\nfunction moveObject(e, object) {\n  if (object != null) {\n    if (object.constructor.name === \"Vertex\") {\n      var position = getGraphXYFromMouseEvent(e);\n      var x = position[0];\n      var y = findNearestGridY(position[1], 0);\n      object.setSX(x);\n      object.setSY(findNearestGridY(y, 1));\n    }\n  }\n}\n\nexport function solidifyObject() {\n  canvasElement.onmousemove = null;\n} // Zoom and pan\n\nexport function setZoom(newZoom) {\n  zoom = newZoom;\n  resetMouseOrigin();\n  setScroll();\n  drawAll();\n} // returns the x,y coordinates of the supplied side for the supplied vertex\n\nexport function getXYFromSide(vertex, side) {\n  var x;\n  var y;\n\n  if (side === \"north\") {\n    x = vertex.sx + vertex.width / 2 + padding;\n    y = vertex.sy;\n  } else if (side === \"east\") {\n    x = vertex.sx + vertex.width;\n    y = vertex.sy + vertex.height / 2;\n  } else if (side === \"south\") {\n    x = vertex.sx + vertex.width / 2 + padding;\n    y = vertex.sy + vertex.height;\n  } else if (side === \"west\") {\n    x = vertex.sx - padding * 2;\n    y = vertex.sy + vertex.height / 2;\n  }\n\n  return [x, y];\n} // Checks all nodes and finds the nearest node within some threshold distance\n// If no nodes are found returns null\n\nfunction findConnectable(x, y) {\n  // The maximum distance allowed for a node to be considered connectable\n  var thesholdDistance = 100; // Get nodes from all items\n  // Note: All drawable objects should include the getNodes function even if it simply returns null\n  // It should return a list, with each item formated as follows\n  // [x, y, ...]\n\n  var nodes = [];\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      var itemNodes = item.getNodes();\n\n      if (itemNodes != null) {\n        nodes = nodes.concat(itemNodes);\n      }\n    }\n  }); // If empty (because there are no nodes) return null\n\n  if (nodes.length === 0) {\n    return null;\n  } // Find closest node\n\n\n  var closestNode = nodes[0];\n  var closestDistance = getDistance(x, y, closestNode[0], closestNode[1]);\n\n  for (var i = 1; i < nodes.length; i++) {\n    var distance = getDistance(x, y, nodes[i][0], nodes[i][1]);\n\n    if (distance < closestDistance) {\n      closestNode = nodes[i];\n      closestDistance = distance;\n    }\n  } // Check if within threshold\n\n\n  if (closestDistance < thesholdDistance) {\n    return closestNode;\n  } // Exceeds threshold return null\n\n\n  return null;\n} // Gets the distance between x1, y1 and x2, y2\n\n\nexport function getDistance(x1, y1, x2, y2) {\n  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n} //returns the object with the nearest cardinal side to the given coordinates,\n// and returns that object + side if a vertex was closest\n\nfunction findNearestObjectAndSide(x, y, verticesOnly) {\n  const edges = [\"north\", \"south\", \"east\", \"west\"];\n  var nearestItem;\n  var lowestDistance = Number.MAX_VALUE;\n  var nearestEdge;\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      if (item.constructor.name === \"Vertex\") {\n        edges.forEach(edge => {\n          var coOrds = getXYFromSide(item, edge); //todo: make this solution much cleaner\n\n          var dist = Math.hypot(coOrds[0] - x * (verticesOnly ? 1 : zoom / 400), coOrds[1] - y * (verticesOnly ? 1 : zoom / 400));\n\n          if (dist < lowestDistance) {\n            lowestDistance = dist;\n            nearestItem = item;\n            nearestEdge = edge;\n          }\n        });\n      } else if (item.constructor.name === \"Arrow\") {\n        if (!verticesOnly) {\n          // find centre of the line and check distance\n          var v1 = item.fromVertex;\n          var s1 = item.fromSide;\n          var v2 = item.toVertex;\n          var s2 = item.toSide;\n          var c1 = getXYFromSide(v1, s1);\n          var c2 = getXYFromSide(v2, s2);\n          var cX = (c1[0] + c2[0]) / 2;\n          var cY = (c1[1] + c2[1]) / 2; //todo: make this solution much cleaner\n\n          var dist = Math.hypot(cX - x * zoom / 400, cY - y * zoom / 400);\n          console.log(\"VD\" + lowestDistance + \" ED\" + dist);\n          console.log(cX, cY, x, y);\n\n          if (dist < lowestDistance) {\n            lowestDistance = dist;\n            nearestItem = item;\n            nearestEdge = null;\n          }\n        }\n      }\n    }\n  });\n\n  if (nearestItem === undefined || lowestDistance >= 200) {\n    return null;\n  } else {\n    return [nearestItem, nearestEdge];\n  }\n} // Finds the object that is intersected with the cursor, returns null if no objects are intersected\n\n\nexport function findIntersected(x, y) {\n  var selectedItem = null;\n  currentObjects.forEach(item => {\n    if (item !== undefined) {\n      if (item.intersects(x, y)) {\n        console.log(\"Intersection detected with \", item.constructor.name);\n        selectedItem = item;\n      }\n    }\n  });\n  return selectedItem;\n}\n\nfunction createObject(canvas, x1, y1, x2, y2) {\n  switch (canvas.tool) {\n    case \"Vertex\":\n      var pos = orderCoordinates(x1, y1, x2, y2);\n      return new Vertex(\"\", \"\", [\"\"], pos[0], pos[1], pos[2], pos[3]);\n\n    case \"Arrow\":\n      var fromNode = findConnectable(x1, y1);\n      var toNode = findConnectable(x2, y2);\n\n      if (fromNode !== null && toNode !== null) {\n        getDownload();\n        return new Arrow(\"\", fromNode[3], fromNode[2], toNode[3], toNode[2]);\n      } else {\n        return undefined;\n      }\n\n    case \"Diamond\":\n    case \"Circle\":\n    case \"Speech\":\n    case \"SpecBox\":\n    case \"Triangle\":\n    default:\n  }\n}\n\nexport function getGraphXYFromMouseEvent(e) {\n  resetMouseOrigin();\n  setScroll();\n  var x = (e.clientX - mouseOriginX) / getEffectiveZoom();\n  var y = (e.clientY - mouseOriginY) / getEffectiveZoom();\n  return [x, y];\n}\n\nfunction exportImage() {\n  getDownload();\n}\n\nexport function getDownload() {\n  document.getElementById(\"downloader\").download = \"image.png\";\n  document.getElementById(\"downloader\").href = canvasElement.toDataURL(\"image/png\").replace(/^data:image\\/[^;]/, 'data:application/octet-stream');\n}\n\nfunction orderCoordinates(sx, sy, ex, ey) {\n  // This code also ensures x1 < x2 and y1 < y2\n  var x1 = Math.min(sx, ex);\n  var y1 = Math.min(sy, ey);\n  var x2 = Math.max(sx, ex);\n  var y2 = Math.max(sy, ey);\n  return [x1, y1, x2, y2];\n} // Gets the effective (percentage) zoom from the current zoom\n\n\nfunction getEffectiveZoom() {\n  return zoom / 100;\n} // This should be used whenever the window itself resizes\n\n\nfunction recalculateScale() {\n  // Adjusts the aspect ratio so it is 1:1 instead of matching the windows.\n  // Also removes blurry rendering\n  let dpi = window.devicePixelRatio;\n  let canvasContainer = document.getElementsByClassName(\"Canvas\")[0];\n  let styleHeight = +getComputedStyle(canvasContainer).getPropertyValue(\"height\").slice(0, -2);\n  let styleWidth = +getComputedStyle(canvasContainer).getPropertyValue(\"width\").slice(0, -2);\n  canvasElement.setAttribute('height', styleHeight * getEffectiveZoom());\n  canvasElement.setAttribute('width', styleWidth * getEffectiveZoom()); // Configurable\n\n  canvasWidth = canvasElement.width;\n  canvasHeight = canvasElement.height;\n}\n\nfunction clearCanvas() {\n  // Fill base canvas\n  canvasContext.fillStyle = \"#ffffff\";\n  canvasContext.fillRect(0, 0, canvasWidth, canvasHeight);\n}","map":{"version":3,"sources":["/ocean/pacific/University/2020/IFB398/overdrive/src/UIElements/CanvasDraw.js"],"names":["Vertex","padding","Arrow","canvasElement","canvasContext","mouseStartX","mouseStartY","scrollX","scrollY","yRows","mouseOriginX","mouseOriginY","canvasWidth","canvasHeight","zoom","currentObjects","resizing","assignElement","elementID","document","getElementById","getContext","resetMouseOrigin","canvasRect","getBoundingClientRect","left","top","recalculateScale","clearCanvas","console","error","drawAll","drawLine","x0","y0","x1","y1","color","beginPath","strokeStyle","moveTo","lineTo","stroke","resetTransform","scale","getEffectiveZoom","i","findNearestGridY","y2","forEach","item","undefined","draw","setScroll","canvasContainerElement","getElementsByClassName","scrollLeft","scrollTop","y","slotHeight","slot","Math","floor","checkResizeBounds","x","vertex","side","constructor","name","bounds","getBounds","x2","abs","bottom","right","inYbounds","inXbounds","resizeObjectOnMouseMove","e","resizeVars","coOrds","getGraphXYFromMouseEvent","expandSide","onMousePress","canvas","tool","onmousemove","onMouseMove","onMouseRelease","newObject","createObject","push","bindNodes","position","globalAlpha","onMiddleClick","log","selectedObject","findIntersected","moveObject","object","setSX","setSY","solidifyObject","setZoom","newZoom","getXYFromSide","sx","width","sy","height","findConnectable","thesholdDistance","nodes","itemNodes","getNodes","concat","length","closestNode","closestDistance","getDistance","distance","sqrt","pow","findNearestObjectAndSide","verticesOnly","edges","nearestItem","lowestDistance","Number","MAX_VALUE","nearestEdge","edge","dist","hypot","v1","fromVertex","s1","fromSide","v2","toVertex","s2","toSide","c1","c2","cX","cY","selectedItem","intersects","pos","orderCoordinates","fromNode","toNode","getDownload","clientX","clientY","exportImage","download","href","toDataURL","replace","ex","ey","min","max","dpi","window","devicePixelRatio","canvasContainer","styleHeight","getComputedStyle","getPropertyValue","slice","styleWidth","setAttribute","fillStyle","fillRect"],"mappings":"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","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {Vertex, padding} from \"../DataStructures/Vertex\";\nimport {Arrow} from \"../DataStructures/Arrow\";\n\n// Core variables\nvar canvasElement;\nvar canvasContext;\n\n// Mouse / Cursor\nvar mouseStartX;\nvar mouseStartY;\n\nvar scrollX = 0;\nvar scrollY = 0;\n\n//todo: make this selectable by the user\nconst yRows = 35;\n\nexport var mouseOriginX;\nexport var mouseOriginY;\n\n// Non zoomed in Width/Height (in pixels)\nvar canvasWidth;\nvar canvasHeight;\n\n// Zoom and Pan\nvar zoom = 200.0;\n\n// Renderable objects\nvar currentObjects = [];\n\nvar resizing = false;\n\n// Init\nexport function assignElement(elementID) {\n    canvasElement = document.getElementById(elementID);\n    canvasContext =  canvasElement.getContext(\"2d\");\n\n    resetMouseOrigin();\n\n}\n\nexport function resetMouseOrigin(){\n    try {\n        var canvasRect = canvasElement.getBoundingClientRect();\n        mouseOriginX = canvasRect.left;\n        mouseOriginY = canvasRect.top;\n        recalculateScale();\n        clearCanvas();\n    }catch{\n        console.error(\"Failed to aquire canvas element\");\n    }\n    drawAll()\n}\n\nfunction drawLine(x0,y0,x1,y1,color) {\n    canvasContext.beginPath();\n    canvasContext.strokeStyle = color;\n    canvasContext.moveTo(x0,y0);\n    canvasContext.lineTo(x1,y1);\n    canvasContext.stroke();\n    canvasContext.strokeStyle = \"#000000\"\n}\n\n// Core functions\nexport function drawAll() {\n    clearCanvas();\n\n    canvasContext.resetTransform();\n    canvasContext.scale(getEffectiveZoom(), getEffectiveZoom());\n\n    for(let i = 0; i < canvasHeight; i+= canvasHeight/yRows/2){\n        let y1 = findNearestGridY(i,1);\n        let y2 = findNearestGridY(i,0);\n        drawLine(0,y1,canvasWidth,y1,\"#D0D0D0\");\n        drawLine(0,y2,canvasWidth,y2,\"#E0E0E0\");\n    }\n\n    currentObjects.forEach((item) => {\n        if (item !== undefined) {\n            item.draw(canvasContext);\n        }\n    })\n}\n\nfunction setScroll(){\n    var canvasContainerElement = document.getElementsByClassName(\"Canvas\")[0];\n    scrollX = canvasContainerElement.scrollLeft;\n    scrollY = canvasContainerElement.scrollTop;\n}\n\n// format co-ordinate so that the value aligns with a row\nfunction findNearestGridY(y,top){\n\n    // distance to topmost top rowLine\n    let slotHeight = 25*zoom/100 * 200/zoom;\n\n    // which row to put it in\n    let slot = Math.floor(y/slotHeight);\n\n    // y co-ordinate of that row (if bottom then go up by row gap)\n    return slotHeight * slot + (slotHeight/2 * + top)\n}\n\nfunction checkResizeBounds(x,y){\n    let vertex = null;\n    let side = null;\n    currentObjects.forEach((item) => {\n        if(item.constructor.name === \"Vertex\") {\n            let bounds = item.getBounds();\n            let x1 = bounds[0];\n            let y1 = bounds[1];\n            let x2 = bounds[2];\n            let y2 = bounds[3];\n\n            let top = Math.abs(y1-y) < 10;\n            let bottom = Math.abs(y2-y) < 10;\n            let left = Math.abs(x1-x) < 10;\n            let right = Math.abs(x2-x) < 10;\n            let inYbounds = y > y1 && y < y2;\n            let inXbounds = x > x1 && x < x2;\n\n            if(top && left){\n                vertex = item;\n                side = \"topLeft\"\n            }else if(top && right){\n                vertex = item;\n                side = \"topRight\";\n            }else if(bottom && left){\n                vertex = item;\n                side = \"bottomLeft\"\n            }else if(bottom && right){\n                vertex = item;\n                side = \"bottomRight\"\n            }else if(left && inYbounds){\n                vertex = item;\n                side = \"left\"\n            }else if(right && inYbounds){\n                vertex = item;\n                side = \"right\"\n            }else if(top && inXbounds){\n                vertex = item;\n                side = \"top\"\n            }else if(bottom && inXbounds){\n                vertex = item;\n                side = \"bottom\"\n            }\n        }\n    });\n    return [vertex,side];\n}\n\nfunction resizeObjectOnMouseMove(e,resizeVars) {\n    let coOrds = getGraphXYFromMouseEvent(e);\n    resizeVars[0].expandSide(resizeVars[1],coOrds[0],coOrds[1]);\n}\n\n// Event based functions\nexport function onMousePress(canvas, x, y) {\n\n    let resizeVars = checkResizeBounds(x,y);\n\n    if(canvas.tool === \"Vertex\") {\n\n        if (resizeVars[0] !== null) {\n            resizing = true;\n            canvasElement.onmousemove = function (e) {\n                resizeObjectOnMouseMove(e, resizeVars)\n            };\n            return\n        }\n    }\n\n\n    setScroll();\n    mouseStartX = x;\n    mouseStartY = findNearestGridY(y,1);\n\n    // Enable example draw while user is deciding shape\n    canvasElement.onmousemove = function(e) {onMouseMove(e, canvas)}\n}\n\nexport function onMouseRelease(canvas, x, y) {\n\n    if(resizing === true){\n        resizing = false;\n        canvasElement.onmousemove = null;\n        return\n    }\n\n    setScroll();\n    var newObject = createObject(canvas, mouseStartX, mouseStartY, x, findNearestGridY(y,0))\n\n    currentObjects.push(newObject);\n\n    if(newObject.constructor.name === \"Arrow\"){\n        newObject.bindNodes()\n    }\n\n    // Disable example draw\n    canvasElement.onmousemove = null;\n\n    drawAll(currentObjects);\n}\n\nfunction onMouseMove(e, canvas) {\n    setScroll();\n    var position = getGraphXYFromMouseEvent(e);\n    var x = position[0]; var y = findNearestGridY(position[1],0);\n\n    var newObject = createObject(canvas, mouseStartX, mouseStartY, x, y);\n\n    // Redraw Existing Objects\n    drawAll(currentObjects);\n\n    // Draw the new object\n    canvasContext.globalAlpha = 0.75;\n    if(newObject !== undefined) {\n        newObject.draw(canvasContext);\n    }\n    canvasContext.globalAlpha = 1.0;\n}\n\nexport function onMiddleClick(canvas, x, y) {\n    console.log(\"Moving Object\");\n    let selectedObject = findIntersected(x,y);\n    canvasElement.onmousemove = function(e) {moveObject(e, selectedObject)}\n}\n\nfunction moveObject(e, object) {\n    if(object != null) {\n        if (object.constructor.name === \"Vertex\") {\n\n            var position = getGraphXYFromMouseEvent(e);\n            var x = position[0];\n            var y = findNearestGridY(position[1], 0);\n\n            object.setSX(x);\n\n            object.setSY(findNearestGridY(y, 1))\n        }\n    }\n}\n\nexport function solidifyObject(){\n    canvasElement.onmousemove = null;\n}\n\n// Zoom and pan\nexport function setZoom(newZoom) {\n    zoom = newZoom;\n\n    resetMouseOrigin();\n    setScroll();\n\n    drawAll();\n}\n\n// returns the x,y coordinates of the supplied side for the supplied vertex\nexport function getXYFromSide(vertex, side) {\n    var x;\n    var y;\n\n\n    if (side === \"north\") {\n        x = vertex.sx + (vertex.width/2)+(padding);\n        y = vertex.sy;\n    } else if (side === \"east\") {\n        x = vertex.sx + vertex.width;\n        y = vertex.sy + (vertex.height/2);\n    } else if (side === \"south\") {\n        x = vertex.sx + (vertex.width/2)+(padding);\n        y = vertex.sy + vertex.height;\n    } else if (side === \"west\") {\n        x = vertex.sx - (padding * 2);\n        y = vertex.sy + (vertex.height/2);\n    }\n\n    return [x,y]\n}\n\n// Checks all nodes and finds the nearest node within some threshold distance\n// If no nodes are found returns null\nfunction findConnectable(x, y) {\n    // The maximum distance allowed for a node to be considered connectable\n    var thesholdDistance = 100;\n\n    // Get nodes from all items\n    // Note: All drawable objects should include the getNodes function even if it simply returns null\n    // It should return a list, with each item formated as follows\n    // [x, y, ...]\n    var nodes = [];\n    currentObjects.forEach((item) => {\n        if (item !== undefined) {\n            var itemNodes = item.getNodes();\n            if (itemNodes != null) {\n                nodes = nodes.concat(itemNodes);\n            }\n        }\n    });\n\n    // If empty (because there are no nodes) return null\n    if (nodes.length === 0) {\n        return null;\n    }\n\n    // Find closest node\n    var closestNode = nodes[0];\n    var closestDistance = getDistance(x, y, closestNode[0], closestNode[1]);\n    for (var i = 1; i < nodes.length; i++) {\n        var distance = getDistance(x, y, nodes[i][0], nodes[i][1]);\n        if (distance < closestDistance) {\n            closestNode = nodes[i];\n            closestDistance = distance;\n        }\n    }\n\n    // Check if within threshold\n    if (closestDistance < thesholdDistance) {\n        return closestNode;\n    }\n\n    // Exceeds threshold return null\n    return null;\n}\n\n// Gets the distance between x1, y1 and x2, y2\nexport function getDistance(x1, y1, x2, y2) {\n    return Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));\n}\n\n\n//returns the object with the nearest cardinal side to the given coordinates,\n// and returns that object + side if a vertex was closest\nfunction findNearestObjectAndSide(x, y, verticesOnly) {\n\n    const edges = [\"north\",\"south\",\"east\",\"west\"];\n\n    var nearestItem;\n    var lowestDistance = Number.MAX_VALUE;\n    var nearestEdge;\n\n    currentObjects.forEach((item) => {\n\n        if(item !== undefined) {\n\n            if (item.constructor.name === \"Vertex\") {\n                edges.forEach((edge) => {\n\n                    var coOrds = getXYFromSide(item, edge);\n                    //todo: make this solution much cleaner\n                    var dist = Math.hypot(coOrds[0] - x * (verticesOnly ? 1 : zoom/400), coOrds[1] - y * (verticesOnly ? 1 : zoom/400));\n                    if (dist < lowestDistance) {\n                        lowestDistance = dist;\n                        nearestItem = item;\n                        nearestEdge = edge;\n                    }\n                })\n            } else if (item.constructor.name === \"Arrow\") {\n                if (!verticesOnly) {\n                    // find centre of the line and check distance\n                    var v1 = item.fromVertex;\n                    var s1 = item.fromSide;\n                    var v2 = item.toVertex;\n                    var s2 = item.toSide;\n\n                    var c1 = getXYFromSide(v1, s1);\n                    var c2 = getXYFromSide(v2, s2);\n\n                    var cX = (c1[0] + c2[0])/2;\n                    var cY = (c1[1] + c2[1])/2;\n\n                    //todo: make this solution much cleaner\n                    var dist = Math.hypot(cX - x*zoom/400, cY - y*zoom/400);\n                    console.log(\"VD\" + lowestDistance + \" ED\" + dist)\n                    console.log(cX,cY,x,y)\n                    if (dist < lowestDistance) {\n                        lowestDistance = dist;\n                        nearestItem = item;\n                        nearestEdge = null;\n                    }\n                }\n            }\n        }\n    });\n  \n    if (nearestItem === undefined || lowestDistance >= 200) {\n        return null\n    } else {\n        return [nearestItem, nearestEdge];\n    }\n}\n\n// Finds the object that is intersected with the cursor, returns null if no objects are intersected\nexport function findIntersected(x, y) {\n    var selectedItem = null;\n    currentObjects.forEach((item) => {\n        if(item !== undefined) {\n            if (item.intersects(x, y)) {\n                console.log(\"Intersection detected with \",item.constructor.name);\n                selectedItem = item;\n            }\n        }\n    });\n    return selectedItem;\n}\n\n\n\nfunction createObject(canvas, x1, y1, x2, y2) {\n    switch(canvas.tool) {\n        case \"Vertex\":\n            var pos = orderCoordinates(x1, y1, x2, y2);\n            return new Vertex(\"\",\"\",[\"\"], pos[0], pos[1], pos[2], pos[3]);\n        case \"Arrow\":\n            var fromNode = findConnectable(x1, y1);\n            var toNode   = findConnectable(x2, y2);\n\n            if (fromNode !== null && toNode !== null) {\n                getDownload();\n                return new Arrow(\"\", fromNode[3], fromNode[2], toNode[3], toNode[2]);\n            } else {\n                return undefined;\n            }\n        case \"Diamond\":\n        case \"Circle\":\n        case \"Speech\":\n        case \"SpecBox\":\n        case \"Triangle\":\n        default:\n    }\n}\n\nexport function getGraphXYFromMouseEvent(e) {\n    resetMouseOrigin();\n    setScroll();\n\n    var x = (e.clientX-mouseOriginX)/getEffectiveZoom();\n    var y = (e.clientY-mouseOriginY)/getEffectiveZoom();\n\n    return [x, y];\n}\n\nfunction exportImage() {\n    getDownload();\n}\n\nexport function getDownload() {\n    document.getElementById(\"downloader\").download = \"image.png\";\n    document.getElementById(\"downloader\").href = canvasElement.toDataURL(\"image/png\").replace(/^data:image\\/[^;]/, 'data:application/octet-stream');\n}\n\nfunction orderCoordinates(sx, sy, ex, ey) {\n    // This code also ensures x1 < x2 and y1 < y2\n    var x1 = Math.min(sx, ex);\n    var y1 = Math.min(sy, ey);\n    var x2 = Math.max(sx, ex);\n    var y2 = Math.max(sy, ey);\n\n    return [x1, y1, x2, y2];\n}\n\n// Gets the effective (percentage) zoom from the current zoom\nfunction getEffectiveZoom() {\n    return zoom/100;\n}\n\n// This should be used whenever the window itself resizes\nfunction recalculateScale() {\n    // Adjusts the aspect ratio so it is 1:1 instead of matching the windows.\n    // Also removes blurry rendering\n    let dpi = window.devicePixelRatio;\n    let canvasContainer = document.getElementsByClassName(\"Canvas\")[0]\n    let styleHeight = +getComputedStyle(canvasContainer).getPropertyValue(\"height\").slice(0, -2);\n    let styleWidth = +getComputedStyle(canvasContainer).getPropertyValue(\"width\").slice(0, -2);\n\n    canvasElement.setAttribute('height', styleHeight * getEffectiveZoom());\n    canvasElement.setAttribute('width', styleWidth * getEffectiveZoom());\n\n    // Configurable\n    canvasWidth = canvasElement.width;\n    canvasHeight = canvasElement.height;\n}\n\nfunction clearCanvas() {\n     // Fill base canvas\n    canvasContext.fillStyle = \"#ffffff\";\n    canvasContext.fillRect(0, 0, canvasWidth, canvasHeight);\n}\n"]},"metadata":{},"sourceType":"module"}